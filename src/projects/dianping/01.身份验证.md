---
title: 01. 身份验证
icon: lock
article: false
category:
  - 项目
  - 黑马点评
tag:
  - 身份验证
  - session
  - JWT
date: 2026-02-15
---

## 一、身份认证与保持登录的三种模式
<!-- <span style="color: #800000ff;"></span> -->
### 模式1：Cookie + Session（传统模式）

<img src="https://i.postimg.cc/RZZBhtPb/whiteboard_exported_image_(2).png" alt="session" style="zoom:67%;" />

具体流程：

1. 用户输入用户名密码提交登录
2. 服务器验证通过，创建Session并存储用户信息
3. 服务器响应：`Set-Cookie: JSESSIONID=abc123; HttpOnly`
4. 浏览器存储Cookie
5. 后续请求自动携带：`Cookie: JSESSIONID=abc123`
6. 服务器通过SessionID查找Session，验证用户身份

> 其中 ==JSESSIONID== 是 Java Web 容器默认用于保存 SessionID 的 Cookie 名称，服务器通过它找到对应的 Session 对象，从而识别用户身份。

### 模式2：Token方案

<img src="https://i.postimg.cc/Bnn0bFhV/whiteboard_exported_image_(3).png" alt="单token" style="zoom:67%;" />

Token流程细节（以JWT为例）：

1. 客户端提交认证信息
2. 服务器验证成功后生成JWT：
   Header.Payload.Signature           
   `{"userId": "123","username": "john","exp": 1672531200, "iat": 1672527600// 签发时间}`
   返回JWT给客户端
3. 客户端存储JWT
4. 客户端在后续请求中通过 HTTP Header 自动携带 JWT。注意：这是HTTP Header，不是 JWT Header,别给自己绕晕了。
5. 服务器验证 JWT 签名，若通过，则解析 Payload 获取用户身份信息，并进行具体的 HTTP 请求处理。

### 模式3：Session + Token混合

<img src="https://i.postimg.cc/HkkgnMSN/whiteboard_exported_image_(4).png" alt="双token" style="zoom:67%;" />

在使用 **JWT + Refresh Token** 的登录体系中，Refresh Token 的 ==可选刷新机制== 有两个核心作用。

首先，它可以保证用户长期无缝登录。Access Token 的有效期通常比较短，用于接口访问。当 Access Token 过期时，客户端可以使用 Refresh Token 获取新的 Access Token，从而无需用户重新登录。通过可选刷新机制，服务器可以延长 Refresh Token 的有效期，让用户在不频繁输入密码的情况下持续使用系统。

其次，可选刷新机制可以提升安全性，防止 Token 被滥用。Refresh Token 如果一直不变，一旦被盗用，攻击者就可能不断刷新 Access Token，长期访问系统。为了降低这种风险，当 Refresh Token 快过期时（比如剩余有效期不到三天），服务器会生成一个新的 Refresh Token，并让旧的失效。这样既保证了长期登录体验，又避免了长时间有效的 Token 被滥用。

总的来说，可选刷新 Refresh Token 是在 ==用户体验与安全性之间的一种平衡==。它只在必要时触发刷新，让用户无需频繁登录，同时保护系统安全。

值得注意的是，刷新操作 <span style="color: #800000ff;">必须依赖用户的实际请求</span>，否则任何 Token 都会自然过期。比如如果我登陆了一个网站在refresh token的有效期内都没有进行任何操作，那就得重新登录了。

### 小结

**传统 Session vs Token-Session (现代无状态 Session)：**

- **传统 Session**：客户端只持有一个 SessionID，服务器存储所有用户数据（如 `userId`、`name`、`permissions` 等）。
- **Token-Session**：客户端持有完整的 Token（包含用户身份信息），服务器不存储用户身份信息，只验证 Token 的签名。

#### 1. **Token 验证流程**

- **Access Token 验证**：服务器只验证 Token 的签名和过期时间，不查询数据库，除非使用了黑名单机制。
- **Refresh Token 刷新**：只有在 Access Token 过期或验证失败时，客户端才使用 Refresh Token 进行数据库查询以获取新的 Access Token。

#### 2. **刷新逻辑**

- **返回错误而非延长 Token**：服务器不会主动延长 Access Token 的有效期。若 Token 过期，服务器返回 `401` 错误，提示客户端使用 Refresh Token 刷新 Access Token（两次请求互相独立）。
- **控制 Refresh Token 使用频率和撤销**：从无状态的脱缰野马 到 有状态的安全可控。

#### 3. **Refresh Token 刷新流程**

- **客户端带 Refresh Token 请求刷新**：通过 HttpOnly Cookie 自动携带 Refresh Token。
- **服务器验证流程**：
  - 计算 <span style="color: #800000ff;">Token 哈希值</span>，查数据库或 Redis 对比存储记录。
  - 检查 Token 是否被撤销（`revoked: true`）。
  - 对比 Token 的过期时间（`expiresAt`）。
  - 可选：检查刷新频率等。
- **验证通过后**：服务器生成新的 Access Token 并可选择更新 Refresh Token（Token 轮换），同时更新最后使用时间。
- **返回结果**：返回新的 Access Token 或错误信息。

#### 4. **安全设计原则**

- **Refresh Token 的严格验证**：由于 Refresh Token 是长期凭证，必须对其进行严格管理和撤销控制。服务器存储的过期时间（`expiresAt`）是权威的，客户端 Cookie 的过期时间仅供参考。即便客户端 Cookie 仍有效，如果服务器端记录已过期或撤销，刷新请求将被拒绝。
