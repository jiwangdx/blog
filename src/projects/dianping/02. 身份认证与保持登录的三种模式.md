---
title: 02. 身份认证与保持登录的三种模式
article: false
category:
  - 项目
  - 《优享生活圈》
tag:
  - session
  - JWT
date: 2026-02-15
---
## 模式1：Cookie + Session（传统模式）
<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1771394613274-343a0416-83db-4d87-8e3c-aca5377c4f5b.png)

具体流程：

> 1. 用户输入用户名密码提交登录
> 2. 服务器验证通过，创建Session并存储用户信息
> 3. 服务器响应：`Set-Cookie: JSESSIONID=abc123; HttpOnly`
> 4. 浏览器存储Cookie
> 5. 后续请求自动携带：`Cookie: JSESSIONID=abc123`
> 6. 服务器通过SessionID查找Session，验证用户身份
>

<font style="color:rgb(216,57,49);">其中JSESSIONID 是 Java Web 容器默认用于保存 SessionID 的 Cookie 名称，服务器通过它找到对应的 Session 对象，从而识别用户身份。</font>

## 模式2：Token方案
<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1771394640405-9e9b673d-146c-4399-87da-9b8c86f356b4.png)

Token流程细节（以JWT为例）：

> 1. 客户端提交认证信息
> 2. 服务器验证成功后生成JWT：
>
>     Header.Payload.Signature 
>
>     `{"userId": "123","username": "john","exp": 1672531200, "iat": 1672527600// 签发时间}`
>
>   返回JWT给客户端
>
> 3. 客户端存储JWT
> 4. 客户端在后续请求中通过 HTTP Header 自动携带 JWT。<font style="color:rgb(216,57,49);">注意：这是HTTP Header，不是 JWT Header,别给自己绕晕了。</font>
> 5. 服务器验证 JWT 签名，若通过，则解析 Payload 获取用户身份信息，并进行具体的 HTTP 请求处理。
>

## 模式3：Session + Token混合
<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1771394652682-b544a1fc-fa6c-49f6-91ef-13161706d594.png)

在使用 **JWT + Refresh Token** 的登录体系中，Refresh Token 的可选刷新机制有两个核心作用。

首先，它可以保证用户<font style="color:rgb(216,57,49);">长期无缝登录</font>。Access Token 的有效期通常比较短，用于接口访问。当 Access Token 过期时，客户端可以使用 Refresh Token 获取新的 Access Token，从而无需用户重新登录。通过可选刷新机制，服务器可以延长 Refresh Token 的有效期，让用户在不频繁输入密码的情况下持续使用系统。

其次，可选刷新机制可以<font style="color:#DF2A3F;">提升安全性</font>，防止 Token 被滥用。Refresh Token 如果一直不变，一旦被盗用，攻击者就可能不断刷新 Access Token，长期访问系统。为了降低这种风险，当 Refresh Token 快过期时（比如剩余有效期不到三天），服务器会生成一个新的 Refresh Token，并让旧的失效。这样既保证了长期登录体验，又避免了长时间有效的 Token 被滥用。

总的来说，可选刷新 Refresh Token 是在 **用户体验与安全性之间的一种平衡**。它只在必要时触发刷新，让用户无需频繁登录，同时保护系统安全。

值得注意的是，<font style="color:rgb(216,57,49);">刷新操作 </font>**<font style="color:rgb(216,57,49);">必须依赖用户的实际请求</font>**，否则任何 Token 都会自然过期。比如如果我登陆了一个网站再refresh token的有效期内都没有进行任何操作，那就得重新登录了。

## 小结
**传统 Session vs Token-Session (现代无状态 Session)：**

+ **传统 Session**：客户端只持有一个 SessionID，服务器存储所有用户数据（如 `userId`、`name`、`permissions` 等）。
+ **Token-Session**：客户端持有完整的 Token（包含用户身份信息），服务器不存储用户身份信息，只验证 Token 的签名。

#### 1. **Token 验证流程**
+ **Access Token 验证**：服务器只验证 Token 的签名和过期时间，不查询数据库，除非使用了黑名单机制。
+ **Refresh Token 刷新**：只有在 Access Token 过期或验证失败时，客户端才使用 Refresh Token 进行数据库查询以获取新的 Access Token。

#### 2. **刷新逻辑**
+ **返回错误而非延长 Token**：服务器不会主动延长 Access Token 的有效期。若 Token 过期，服务器返回 `401` 错误，提示客户端使用 Refresh Token 刷新 Access Token（两次请求互相独立）。
+ **控制 Refresh Token 使用频率和撤销**：从无状态的脱缰野马 到 有状态的安全可控。

#### 3. **Refresh Token 刷新流程**
+ **客户端带 Refresh Token 请求刷新**：通过 HttpOnly Cookie 自动携带 Refresh Token。
+ **服务器验证流程**：
    - 计算 Token 哈希，查数据库或 Redis 对比存储记录。
    - 检查 Token 是否被撤销（`revoked: true`）。
    - 对比 Token 的过期时间（`expiresAt`）。
    - 可选：检查刷新频率等。
+ **验证通过后**：服务器生成新的 Access Token 并可选择更新 Refresh Token（Token 轮换），同时更新最后使用时间。
+ **返回结果**：返回新的 Access Token 或错误信息。

#### 4. **安全设计原则**
+ **Refresh Token 的严格验证**：由于 Refresh Token 是长期凭证，必须对其进行严格管理和撤销控制。服务器存储的过期时间（`expiresAt`）是权威的，客户端 Cookie 的过期时间仅供参考。即便客户端 Cookie 仍有效，如果服务器端记录已过期或撤销，刷新请求将被拒绝。

