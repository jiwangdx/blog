---
title: 06. LangChain4j AI顾问
article: false
category:
  - 项目
  - 《优享生活圈》
tag:
  - rag
  - LangChain4j
  - MCP
date: 2026-02-15
---
## 一、需求实现
- 设计并实现分层多轮会话管理机制，基于Redis构建短期记忆，MySQL实现中期记忆和长期记忆，支持会话列表管理。

- 构建架构知识库，实现商家信息的自动向量化处理和定期更新，提升语义检索准确性。

- 开发工具集，实现商家信息查询、预约下单等业务功能与大模型的无缝集成。

- 优化系统性能，实现增量更新机制，定期全量更新兜底，结合分页查询，减少计算资源和内存的消耗，提升响应速度。

:::info 背景
现在的大模型是非常热门的一个方向，业界也有很多的一些传统项目都在结合AI进行这种智能化升级。所以我就思考自己这个项目是不是也能结合AI去做一些帮助用户的功能。

我的想法是通过Java调用大模型给用户提供一个智能AI顾问，它有点类似于一个GPT对话式的顾问，

那它所能提供的功能，例如：

    1. 查询商家的信息
    2. 查询商家的优惠券信息
    3. 查询用户拥有的优惠券信息
    4. 预约到店消费服务
    5. 查询用户到店消费服务的预约详情
    6. 结合具体商家的信息，给用户做店铺推荐或玩乐安排等

:::

为了实现智能AI顾问，首先我就去学习了<font style="background-color:#FBDE28;">LangChain4j</font>这个Java调用大模型的工具框架，其中印象比较深刻的是<font style="background-color:#FBDE28;">RAG和FunctionCalling</font>

+ 像用户的一些问题，要**结合平台的文档或数据**才能够回答，这时候就需要使用<font style="background-color:#81DFE4;">RAG</font>，
    - 我需要把平台的文档或数据向量化存储到RAG知识库(向量数据库)
    - 当用户发出问题后，Java服务会<font style="color:rgb(216,57,49);">先根据用户的问题从知识库中检索对应的知识片段</font>
    - 得到知识片段后，Java服务需要结合用户的问题以及知识库中检索到的知识片段组织要发送给大模型的消息
    - 大模型接收到消息后会同时根据用户的问题、知识库检索到的知识片段以及自身的知识储备，生成对应的结果响应给Java服务，最终再返回给用户

可以利用rag来做个店铺推荐的服务。

在智能顾问的 RAG 设计中，最初采用 PDF 静态知识库方式存储商家信息，这在商家数量少、信息变化不频繁时可以正常工作，也实现了基本的店铺问答和推荐功能。

但是随着业务发展，考虑到商家信息实际上是动态变化的——有新的商家入驻，已有商家的优惠、营业时间或其他信息也会更新。使用 PDF 做静态知识库就存在两个问题：

+ **更新不及时**，新加入或修改的商家信息不能立即被模型检索到；
+ **全量向量化成本高**，每次全量处理所有商家信息会消耗大量 Token，浪费计算资源。

为此，将方案优化为<font style="background-color:#81DFE4;">直接从数据库读取商家信息</font>。首次运行时，进行全量向量化，将所有商家信息生成 embedding 并写入向量库；后续定时任务只读取 `update_time` 在时间窗口内的新增或更新商家，实现**<font style="background-color:#81DFE4;">增量更新</font>**，只对变动数据进行 embedding。

这种方式的好处是：

+ **降低 Token 消耗和计算成本**，不必每次都全量处理；
+ **保证向量库及时更新**，新入驻或变更的商家信息能被快速检索；
+ **具备可扩展性**，适应商家数量增长和业务扩展。

后来在看代码时，我才发觉自己从数据库读取商家数据时使用的是一次性 `List`，由于商家表比较大，这会占用大量内存，容易造成性能问题。 于是我改成使用<font style="background-color:#81DFE4;">分页查询</font>，每次只读取一部分数据，这样既降低了内存压力，又保证了数据处理的稳定性。

<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1771390862780-14ae747b-e21b-4ef1-be21-abd198234387.png)

+ <font style="background-color:#81DFE4;">FunctionCalling</font> 可以智能地根据用户的输入调用我们准备好的工具方法。
    - 首先我需要准备一些工具方法，例如查询商家信息、新增预约信息等等的方法
    - 当用户发出问题后，Java服务需要组织提交给大模型的数据，而这些数据中需要描述清楚Java服务中有哪些函数能够被大模型调用。每一个函数的描述都包含三个部分，方法名称、方法作用、方法入参。
    - 当Java服务把这些数据发送给大模型后，大模型会先根据用户的问题以及上下文拆解任务，从而判断是否需要调用函数。如果有函数需要调用，则把需要调用的函数的名称，以及调用时需要使用的参数准备好一并响应给Java服务。
    - Java服务接收到响应后需要执行对应的函数，得到对应的结果，接下来把得到的结果和之前信息一块组织好再发送给大模型。最后再响应给用户。

<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1771390862851-2f6ad4a7-a1c2-4385-8fd9-57fc839ff8dc.png)

:::warning 注意
_**使用Redis支持会话记忆是什么意思？**_

大模型不具备记忆能力，每次会话都是独立的。要想让大模型产生记忆的效果，唯一的方法就是把之前聊天的内容和新的内容一起发送给大模型。也就是说我们需要存储一个会话的互相发过的消息。

_**这个会话的消息是需要存储的，且不能只存储在内存里，否则如果后端重启就消失了，所以需要持久化，所以存储在Redis中（String存储即可），有效期设置一天足够。**_

:::

## 二、核心概念理解
### MCP（Model Context Protocol）
MCP是一种用于规范大模型与应用系统间上下文交互的协议标准，核心解决多轮对话中的上下文管理、工具调用和状态同步问题。虽然我这个项目未直接使用MCP，但实现了类似的核心功能：

首先，在会话上下文管理方面，项目通过Redis自定义 RedisChatMemoryStore ，将对话历史序列化存储，确保多轮对话的连贯性，这与MCP的<font style="background-color:rgba(183,237,177,0.8);">上下文管理目标</font>一致，只是实现方式更偏向业务定制。

其次，在工具调用能力上，项目通过LangChain4J的 @Tool 注解定义商家信息查询、预约下单等工具，实现模型与业务系统的交互，这对应MCP的<font style="background-color:rgba(183,237,177,0.8);">工具调用标准化功能</font>，但我们直接基于框架注解实现，开发更快捷。

最后，从技术趋势看，MCP的标准化优势在于降低多模型集成的复杂度，适合大型系统；而我们的实现方式更灵活，适合中小规模项目的快速迭代。未来若需扩展多模型支持，引入MCP相关框架会是不错的选择。

### RAG（Retrieval-Augmented Generation）
RAG是一种技术架构，通过检索知识库信息来增强模型回答的准确性。和MCP相比<font style="background-color:rgba(183,237,177,0.8);">两者关注点不同</font>，但可以协同工作：

比如在项目中，实现了基于向量存储的RAG架构，用于检索商家信息。如果引入MCP，可以：

    1. 标准化检索结果的格式，确保模型能更准确理解知识
    2. 规范工具调用接口，简化商家信息查询、预约下单等功能的集成
    3. 统一上下文传递机制，提升多轮对话的连贯性

3.如果大模型要记很久的消息呢，我通过了解的话，大概是通过分级存储的方式去实现。

所以我尝试实现了一下，建了一张专门存储会话信息的表，定时任务轮询去检查有没有过期信息，有则删除

## 三、核心代码
### 大模型服务构建与配置
```java
// 智能客服服务接口
@AiService(
    wiringMode = EXPLICIT,           // 手动装配
    chatModel = "openAiChatModel",   // 大模型配置
    streamingChatModel = "openAiStreamingChatModel",  // 流式响应
    chatMemoryProvider = "chatMemoryProvider",        // 会话记忆
    contentRetriever = "contentRetriever",            // 知识检索
    tools = {"shopTool","reservationTool","voucherTool"}  // 业务工具
)
public interface ConsultantService {
    // 系统提示词配置
    @SystemMessage(fromResource = "system.txt")

    // 流式对话方法
    Flux<String> chat(@MemoryId String memoryId, @UserMessage String message);
}
```

### 多轮会话记忆管理
```java
// Redis会话记忆存储
@Repository
public class RedisChatMemoryStore implements ChatMemoryStore {
    @Autowired
    private StringRedisTemplate redisTemplate;

    // 获取会话消息
    public List<ChatMessage> getMessages(Object memoryId) {
        String json = redisTemplate.opsForValue().get(memoryId);
        return ChatMessageDeserializer.messagesFromJson(json);
    }

    // 更新会话消息
    public void updateMessages(Object memoryId, List<ChatMessage> list) {
        String json = ChatMessageSerializer.messagesToJson(list);
        redisTemplate.opsForValue().set(memoryId.toString(), json, Duration.ofDays(1));
    }

    // 删除会话消息
    public void deleteMessages(Object memoryId) {
        redisTemplate.delete(memoryId.toString());
    }
}
```

### 基于Function Calling的业务工具集成
```java
// 商家信息工具
@Component
public class ShopTool {
    @Autowired
    private ShopService shopService;

    // 工具方法：根据商家名称查询信息
    @Tool("根据商家名称查询商家信息")
    public Shop findShop(@P("商家名称") String shopName) {
        return shopService.findShop(shopName);
    }
}
```

```java
// 预约工具
@Component
public class ReservationTool {
    @Autowired
    private ReservationService reservationService;

    // 工具方法：添加预约信息
    @Tool("预约到店消费服务")
    public void addReservation(
        @P("用户姓名") String name,
        @P("用户手机号") String phone,
        @P("预约到店消费时间,格式为: yyyy-MM-dd'T'HH:mm") String communicationTime,
        @P("预约指定的商家") String shopName
    ) {
        Reservation reservation = new Reservation(null, name, phone, 
                                                  LocalDateTime.parse(communicationTime), shopName);
        reservationService.insert(reservation);
    }
}
```

### RAG架构的动态知识库管理
```java
// 向量存储服务
@Service
public class EmbeddingStoreService {
    @Autowired
    private ShopMapper shopMapper;
    @Autowired
    private EmbeddingModel embeddingModel;
    @Autowired
    private EmbeddingStore store;

    // 应用启动时全量加载
    @PostConstruct
    public void init() {
        fullUpdate();  // 首次全量加载
    }

    // 定期增量更新
    @Scheduled(fixedRate = 10000)
    public void periodicIncrementalUpdate() {
        incrementalUpdate();  // 增量更新
    }

    // 全量更新方法
    private void fullUpdate() {
        // 1. 查询所有商家数据
        List<Shop> shops = shopMapper.selectList(new QueryWrapper<>());
        // 2. 转换为文档
        List<Document> documents = convertToDocuments(shops);
        // 3. 向量化并存储
        ingestDocuments(documents);
    }

    // 增量更新方法
    private void incrementalUpdate() {
        // 1. 查询时间窗口内的更新数据
        List<Shop> shops = shopMapper.selectList(queryWrapper);
        // 2. 转换为文档
        List<Document> documents = convertToDocuments(shops);
        // 3. 向量化并存储
        ingestDocuments(documents);
    }
}
```

## 四、长期记忆的实现
### 整体架构思路
暂时无法在南开飞书文档外展示此内容

核心思路 ：

+ 短期记忆 ：Redis 缓存，高频访问（7天过期）
+ 中/长期记忆 ：MySQL 持久化，90天保留，重要会话永久保存（由用户点击收藏被动触发）
+ 会话命名 ：自动取首条用户消息 + 支持用户自定义

### 核心组件伪代码
#### Redis 短期记忆 (RedisChatMemoryStore)
```java
// 实现 LangChain4j 标准接口
class RedisChatMemoryStore {

    // 获取历史消息：先查 Redis，没有再查数据库
    function getMessages(memoryId):
                         sessionId = memoryId.toString()
                         json = redis.get(sessionId)

    if json != null:
return deserialize(json)  // 缓存命中

// 缓存未命中，从数据库加载
messages = persistenceService.loadSession(sessionId)
return messages

// 更新消息：更新 Redis + 异步写数据库
function updateMessages(memoryId, messages):
sessionId = memoryId.toString()
json = serialize(messages)

// 更新 Redis（7天过期）
redis.set(sessionId, json, expire=7天)

// 异步写数据库（不阻塞主流程）
async {
    persistenceService.persistSession(sessionId, messages)
    persistenceService.autoSetSessionTitle(sessionId, messages)  // 自动命名
}
}
```

#### 会话持久化服务 (SessionPersistenceService)
```java
class SessionPersistenceService {

    // 持久化会话：存在则更新，不存在则插入
    function persistSession(sessionId, messages):
    messagesJson = serialize(messages)

    if exists(sessionId):
update chat_session 
set messages = ?, updated_at = NOW() 
where session_id = ?
else:
insert into chat_session(session_id, messages, created_at, ...)
values(?, ?, NOW(), ...)

// 自动设置会话标题（取首条用户消息前30字）
function autoSetSessionTitle(sessionId, messages):
title = extractFirstUserMessage(messages)  // 取首条用户消息，前30字

update chat_session 
set session_title = ? 
where session_id = ? and session_title is null  // 仅在为空时设置

// 获取所有会话列表（同时转下划线为驼峰）
function getAllSessions():
results = select * from chat_session order by last_access_time desc

for row in results:
row.sessionId = row.session_id
row.sessionTitle = row.session_title
row.isImportant = row.is_important
// ... 其他字段转换

return results
}
```

#### 会话管理接口 (SessionController)
```java
@RestController
@RequestMapping("/api/sessions")
class SessionController {

    // 创建新会话
    @PostMapping("/create")
    function createInitialSession(request):
                                  sessionId = request.sessionId
                                  persistenceService.createInitialSession(sessionId)

                                  // 获取会话列表
                                  @GetMapping("/list")
                                  function getAllSessions():
    return persistenceService.getAllSessions()

// 加载会话历史
@GetMapping("/load/{sessionId}")
function loadSession(sessionId):
return persistenceService.loadSession(sessionId)

// 标记重要
@PostMapping("/mark-important")
function markSessionAsImportant(request):
persistenceService.markSessionAsImportant(request.sessionId, request.isImportant)

// 删除会话
@DeleteMapping("/delete/{sessionId}")
function deleteSession(sessionId):
persistenceService.deleteSession(sessionId)

// ========== 新增：重命名会话 ==========
@PostMapping("/rename")
function renameSession(request):
persistenceService.updateSessionTitle(request.sessionId, request.title)
}
```

## 五、rag优化
巧妙的是，无论是新增还是基于旧数据的修改，都能解决，因为代码逻辑是查询向量库是否存在与对应商户ID相关的向量，具体方法为`inMemoryStore.remove(shopIdStr)`。如果 ID 不存在， 该方法不会报错 ，只会什么都不做

但是！！！删除不行，为了解决删除的问题，在向量管理中，我设计了一个 映射表 来记录商铺ID和向量ID的对应关系。<font style="background-color:rgba(183,237,177,0.8);">每次增量更新时</font>，先对比映射表和数据库，找出已被删除的商铺，然后清理对应的向量和映射表记录。

每次增量更新时：

1. 查询映射表中所有商铺ID
2. 查询数据库当前所有商铺ID 
3. 对比两边，找出在映射表中存在但数据库已不存在的 → 孤立记录
4. 删除这些孤立记录的向量 + 映射表记录

```java
// 每次增量更新时，检测并删除被删除的商铺向量

function detectAndRemoveOrphanedEmbeddings():
// 1. 获取映射表中所有商铺ID
mappingShopIds = SELECT shop_id FROM shop_embedding_mapping

// 2. 获取数据库当前所有商铺ID
dbShopIds = SELECT id FROM shop

// 3. 找出孤立的商铺（在映射表中存在，但数据库已删除）
orphanedIds = mappingShopIds - dbShopIds

// 4. 删除孤立向量和映射表记录
for shopId in orphanedIds:
embeddingId = SELECT embedding_id WHERE shop_id = shopId
vectorStore.remove(embeddingId)      // 删除向量
DELETE FROM mapping WHERE shop_id = shopId  // 删除映射记录
```

:::warning 注意
在前期实现增量更新时，我们采用了<font style="color:#DF2A3F;">分表查询</font>的方式进行数据扫描。目前的处理逻辑同样嵌套在分表查询流程之下：先按分表策略查询 `shop` 表数据，再基于分表结果执行差集计算。这种方式能够有效适配大数据量场景，降低单次数据加载规模，使整体内存占用更加可控，提升系统的稳定性与可扩展性。

:::

