---
title: 05. 限流
article: false
category:
  - 项目
  - 《优享生活圈》
tag:
  - 滑动窗口
  - AOP
date: 2026-02-15
---
## **一、滑动窗口限流**
+ **滑动窗口限流**： 使用 注解+AOP+Redis 实现限流，支持全局、IP、用户多维度，防止系统过载、刷券、爬虫；
    - 对秒杀接口使用全局限流，防止系统过载
    - _对用户领取优惠券使用用户级限流，防止刷券_
    - 对商家信息查询使用IP级限流，防止爬虫

:::info 背景
+ 优惠券秒杀时<font style="background-color:#FBDE28;">流量</font>过大，需要限流，保证系统的可用性。
+ 在领取无限制的优惠券时，为了避免恶意刷券，其实可以<font style="background-color:rgba(255,246,122,0.8);">针对用户</font>进行限流。
+ 针对现在的爬虫，可以<font style="background-color:#FBDE28;">针对IP</font>进行限流。

需要设计一个限流组件。来完成这几种特殊情况的限制，保证系统的可用性、安全性、稳定性。

:::

如何实现这个限流组件呢？对这个限流组件首先有几点需求

+ 第一，无侵入式
+ 第二，高性能
+ 第三，容易使用

无侵入式和容易使用，可以使用<font style="background-color:rgba(255,246,122,0.8);">AOP切面结合自定义注解实现</font>，而高性能可以使用Redis实现。

**要使用哪种限流算法呢？**

我了解有固定窗口、滑动窗口、漏桶、令牌桶 这四种限流算法

1. 固定窗口在临界点会有允许两倍流量的临界问题。
2. 漏桶算法核心是请求以固定的速率被处理，不管请求的突发性。它的工作方式类似于一个底部有孔的桶，水（请求）以任意速率流入桶中，但只能以恒定的速率流出。如果桶满了，多余的请求会被丢弃。
	缺点：漏桶算法无法处理突发流量。即使系统有空闲资源，请求也只能以固定速率处理，这对于秒杀场景来说不够灵活。在优惠券秒杀时，我们希望系统在有能力的情况下尽可能处理更多请求，而漏桶的固定流出速率会导致系统资源无法充分利用，在突发流量时大量请求被丢弃，用户体验较差。
3. 令牌桶算法以固定速率生成令牌放入桶中，每个请求需要获取一个令牌才能被处理。如果桶中有令牌，请求可以立即被处理，允许一定程度的突发流量（因为桶中积累的令牌可以被一次性使用）。
	缺点：如果桶中积累了令牌，恶意用户可以利用这些令牌在瞬间发送大量请求，也就是所谓的脉冲攻击，导致其他用户无令牌可用。

最终选择了<font style="background-color:rgba(255,246,122,0.8);">滑动窗口算法</font>实现限流，将时间窗口细分为多个小窗口，统计滑动窗口内的总请求数。随着时间推移，窗口向前滑动，旧的小窗口数据过期。

+ 第一 它可以提供精确的控制。
+ 第二 滑动窗口通过限制每个时间窗口内的请求数量，通常能够有效应对脉冲攻击。即使攻击者试图在短时间内发起大量请求，由于每个时间窗口内的请求数是有上限的，滑动窗口可以<font style="color:rgb(216,57,49);">有效抑制这种突发流量</font>。

<font style="background-color:#F1A2AB;">具体的流程细节：</font>

1. 自定义限流注解：包含参数 限流key前缀、时间窗口大小、时间窗口内允许的请求数、限流提示信息、限流维度，其中限流维度支持按 全局限流、用户限流、IP限流，不同的维度适用于不同的场景。

**有了这个自定义限流注解后，我们就可以把注解加到对应的接口上，并设置对应的参数**

> 我们<font style="background-color:rgba(183,237,177,0.8);">需要拦截所有加了自定义限流注解的接口方法</font>，也就是还需要实现<font style="color:rgb(216,57,49);">AOP切面</font>
>

2. **限流切面处理：**获取到注解上的参数**，**限流key前缀、时间窗口大小、时间窗口内允许的请求数、限流提示信息、限流维度，<font style="color:rgb(216,57,49);">执行限流Lua脚本，且把参数传递进去。</font>

3. **限流Lua脚本：**使用 Redis 的<font style="background-color:rgba(183,237,177,0.8);"> ZSet </font>结构实现滑动窗口限流。每个请求以时间戳作为 score 插入有序集合。每次请求先通过 <font style="background-color:rgba(183,237,177,0.8);">Z REM RANGE BYSCORE</font> 删除窗口外的数据，然后通过<font style="background-color:rgba(183,237,177,0.8);"> ZCARD </font>获取当前窗口内请求数量，如果未超过阈值则通过 <font style="background-color:rgba(183,237,177,0.8);">ZADD</font> 插入当前请求，否则拒绝。本逻辑通过 Lua 脚本执行，保证删除、统计和插入的原子性。

## 二、限流算法
### 2.1 固定窗口限流(又称计数器算法)
首先维护一个计数器，将单位时间段当做一个窗口，计数器记录这个窗口接收请求的次数。

+ 当次数少于限流阀值，就允许访问，并且计数器+1
+ 当次数大于限流阀值，就拒绝访问。
+ 当前的时间窗口过去之后，计数器清零。

假设单位时间是1秒，限流阀值为3。在单位时间1秒内，每来一个请求,计数器就加1，如果计数器累加的次数超过限流阀值3，后续的请求全部拒绝。等到1s结束后，计数器清0，重新开始计数。

<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1771390842508-866c0f35-e955-4521-b187-d4b3cfcb1d82.png)

这种算法有一个很明显的<font style="color:rgb(216,57,49);">临界问题</font>：假设限流阀值为5个请求，单位时间窗口是1s,如果我们在单位时间内的前0.8-1s和1-1.2s，分别并发5个请求。虽然都没有超过阀值，但是如果算0.8-1.2s,则并发数高达10，已经超过单位时间1s不超过5阀值的定义啦。

### 2.2 滑动窗口限流
滑动窗口限流解决固定窗口临界值的问题。它将单位时间周期分为n个小周期，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。

<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1771390842554-2b1b277c-d705-44bb-b77a-cc8a06f6924a.png)

滑动窗口的格子周期划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。

滑动窗口算法虽然解决了固定窗口的临界问题，但是一旦到达限流后，请求都会直接暴力被拒绝。酱紫我们会损失一部分请求，这其实对于产品来说，并不太友好。

### 2.3 漏桶算法
漏桶算法面对限流，就更加的柔性，不存在直接的粗暴拒绝。

它的原理很简单，可以认为就是注水漏水的过程。往漏桶中以任意速率流入水，以固定的速率流出水。当水超过桶的容量时，会被溢出，也就是被丢弃。因为桶容量是不变的，保证了整体的速率。

<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1771390842582-cf38392b-6a16-447e-87b0-1fd5c3887331.png)

+ 流入的水滴，可以看作是访问系统的请求，这个流入速率是不确定的。
+ 桶的容量一般表示系统所能处理的请求数。
+ 如果桶的容量满了，就达到限流的阀值，就会丢弃水滴（拒绝请求）
+ 流出的水滴，是恒定过滤的，对应服务按照固定的速率处理请求。

在正常流量的时候，系统按照固定的速率处理请求，是我们想要的。但是<font style="color:rgb(216,57,49);">面对突发流量的时候，漏桶算法还是循规蹈矩地处理请求，这就不是我们想看到的啦。</font>流量变突发时，我们希望系统尽快处理请求，提升用户体验。

### 2.4 令牌桶算法
面对突发流量的时候，我们可以使用令牌桶算法限流。

+ 有一个令牌管理员，根据限流大小，定速往令牌桶里放令牌。
+ 如果令牌数量满了，超过令牌桶容量的限制，那就丢弃。
+ 系统在接受到一个用户请求时，都会先去令牌桶要一个令牌。如果拿到令牌，那么就处理这个请求的业务逻辑；
+ 如果拿不到令牌，就直接拒绝这个请求。

<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1771390842544-bf617358-f74d-4cb8-9abe-1b2cecef0986.png)

如果令牌发放的策略正确，这个系统即不会被拖垮，也能提高机器的利用率。

## 三、代码实现
### 3.1 自定义限流注解 `RateLimiter`
**自定义限流注解：**包含限流key前缀、时间窗口大小、时间窗口内允许的请求数、限流提示信息、限流维度

window时间窗口大小 和 limit时间窗口内允许的请求数 这两个参数 取决于自己的系统的并发量

+ 例如可以设置 1s 内 允许 100 个请求，则QPS最高是100
+ 例如可以设置 0.5s 允许100个请求，则QPS最高是200

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RateLimiter {
    /**
     * 限流key前缀
     */
    String key() default "rate_limit:";

    /**
     * 时间窗口大小（秒）
     */
    int window() default 10;

    /**
     * 时间窗口内允许的请求数
     */
    int limit() default 20;

    /**
     * 限流提示信息
     */
    String message() default "系统繁忙，请稍后再试";

    /**
     * 限流维度（默认按方法限流）
     */
    LimitType type() default LimitType.METHOD;

    enum LimitType {
    /**
         * 按调用方IP限流
         */
    IP,
    /**
         * 按用户ID限流
         */
    USER,
    /**
         * 按方法限流/全局限流（默认）
         */
    METHOD
}
}
```

### 3.2 限流切面处理 `RateLimiterAspect`
```java
@Aspect
@Component
public class RateLimiterAspect {

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    // 限流Lua脚本
    private static final DefaultRedisScript<Long> SLIDING_WINDOW_SCRIPT;

    static {
        SLIDING_WINDOW_SCRIPT = new DefaultRedisScript<>();
        SLIDING_WINDOW_SCRIPT.setLocation(new ClassPathResource("limiter.lua"));
        SLIDING_WINDOW_SCRIPT.setResultType(Long.class);
    }

    // 前置拦截 注解了rateLimiter的方法
    @Before("@annotation(rateLimiter)")
    public void doBefore(JoinPoint point, RateLimiter rateLimiter) {
        System.out.println("进入切面逻辑!!!");

        // 获取注解上的参数
        String key = rateLimiter.key();
        long window = rateLimiter.window();
        long limit = rateLimiter.limit();

        // 构建完整的限流key
        String fullKey = buildRateLimitKey(point, rateLimiter, key);
        // 执行限流脚本
        Long result = executeSlidingWindowScript(fullKey, window, limit);

        // 如果返回0表示被限流
        if (result != null && result == 0) {
            throw new RateLimitException(rateLimiter.message());
        }
    }

    /**
     * 执行滑动窗口限流脚本
     *
     * @param key    限流key
     * @param window 时间窗口（秒）
     * @param limit  限制请求数量
     * @return 当前窗口内请求数量计数（如果被限流返回0）
     */
    public Long executeSlidingWindowScript(String key, Long window, Long limit) {
        long now = System.currentTimeMillis();
        System.out.printf("key:%s, window:%d, limit:%d\n", key, window, limit);
        return stringRedisTemplate.execute(
            SLIDING_WINDOW_SCRIPT,
            Collections.singletonList(key),
            window.toString(), limit.toString(), Long.toString(now)
        );
    }

    /**
     * 构建限流key
     */
    private String buildRateLimitKey(JoinPoint point, RateLimiter rateLimiter, String baseKey) {
        StringBuilder keyBuilder = new StringBuilder(baseKey);

        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();

        // 添加类名和方法名
        keyBuilder.append(method.getDeclaringClass().getName())
        .append(":")
        .append(method.getName());

        // 根据限流类型添加额外维度
        switch (rateLimiter.type()) {
            case IP:
                keyBuilder.append(":ip:").append(getClientIp());
                break;
            case USER:
                keyBuilder.append(":user:").append(getCurrentUserId());
                break;
            case METHOD:
            default:
                // 方法级限流使用默认key
                break;
        }

        return keyBuilder.toString();
    }

    /**
     * 获取客户端IP
     */
    private String getClientIp() {
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        String ip = request.getHeader("X-Forwarded-For");
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        return ip;
    }

    /**
     * 获取当前用户ID（需要根据实际系统实现）
     */
    private String getCurrentUserId() {
        // 这里需要根据你的认证系统实现
        // 例如从SecurityContext获取认证用户
        return "anonymous"; // 默认返回匿名用户
    }
}
```

### 3.3 滑动窗口限流Lua脚本 limiter.lua
```java
local key = KEYS[1]
local window = tonumber(ARGV[1]) -- 时间窗口(单位为秒)
local limit = tonumber(ARGV[2]) -- 时间窗口内限制的次数
local now = tonumber(ARGV[3])  -- 当前时间(单位为毫秒)

-- 校验传进来的参数是否为空,若为空直接返回错误
if not window or not limit or not now then
return redis.error_reply("Invalid input parameters")
end

window = window * 1000  -- 单位由秒->毫秒

-- 删除超出时间窗口的数据
-- Redis命令ZREMRANGEBYSCORE: 从有序集合中移除指定分数区间的成员。 删除所有分数在 [0,now-window) 的请求记录
-- now是当前时间戳,window是时间窗口, 0是最小分数,now-window是时间窗口外最大的分数,这样就能删除超出窗口的元素
redis.call('ZREMRANGEBYSCORE', key, 0, now - window)

-- 获取当前窗口内的请求数量
-- Redis命令ZCARD: 返回有序集合中成员的数量,因为已经删除了超出时间窗口的元素，所以直接返回集合的成员数量即可获取当前时间窗口的请求数量
local current = redis.call('ZCARD', key)

-- 若"当前时间窗口内的请求数量" 小于 "时间窗口内限制的次数"
if current < limit then
-- 添加当前请求（使用毫秒时间戳+随机数作为member,时间戳作为score）
math.randomseed(now)
local random = math.random(1000000)
redis.call('ZADD', key, now, now .. '-' .. random)
-- 更新过期时间
redis.call('EXPIRE', key, window / 1000)
return current + 1
else
-- 若"当前时间窗口内的请求数量" 大于等于 "时间窗口内限制的次数", 则应该限制本次请求,返回 0,表示限流
return 0
end
```

### 3.4 限流异常类 `RateLimitException`
```java
package com.hmdp.limiter.exception;

public class RateLimitException extends RuntimeException {
    public RateLimitException(String message) {
        super(message);
    }
}
```

### 3.5 全局异常处理 `WebExceptionAdvice`
```java
@Slf4j
@RestControllerAdvice
public class WebExceptionAdvice {

    // 全局异常处理捕捉，记录通用日志，返回给前端通用响应 Result.fail("服务器异常")
    @ExceptionHandler(RuntimeException.class)
    public Result handleRuntimeException(RuntimeException e) {
        log.error(e.toString(), e);
        return Result.fail("服务器异常:" + e.getMessage());
    }
}
```

## 四、使用示例
### 4.1 在Controller方法上使用限流注解
```java
@RestController
@RequestMapping("/api/coupon")
public class CouponController {

    /**
     * 全局秒杀接口限流（全局限流）
     * 10秒内最多允许100次请求
     */
    @GetMapping("/seckill")
    @RateLimiter(
        key = "coupon:seckill:global",
        window = 10,
        limit = 100,
        message = "秒杀活动太火爆，请稍后再试",
        type = RateLimiter.LimitType.GLOBAL
    )
    public String seckillCoupon() {
        // 秒杀业务逻辑
        return "秒杀成功";
    }

    /**
     * 按用户限流的优惠券领取接口
     * 每个用户60秒内最多领取3张优惠券
     */
    @GetMapping("/claim")
    @RateLimiter(
        key = "coupon:claim:",
        window = 60,
        limit = 3,
        message = "您领取优惠券过于频繁，请稍后再试",
        type = RateLimiter.LimitType.USER
    )
    public String claimCoupon() {
        // 优惠券领取逻辑
        return "领取成功";
    }

    /**
     * 按IP限流的商家信息查询接口
     * 每个IP每秒最多查询5次商家信息
     */
    @GetMapping("/merchant")
    @RateLimiter(
        key = "merchant:info:",
        window = 1,
        limit = 5,
        message = "查询过于频繁，请稍后再试",
        type = RateLimiter.LimitType.IP
    )
    public String getMerchantInfo() {
        // 查询商家信息
        return "商家信息";
    }
}
```

### 4.2 测试限流效果
```java
@RestController
@RequestMapping("/voucher-order")
public class VoucherOrderController {

    @Resource
    private IVoucherOrderService voucherOrderService;

    // @PostMapping("seckill/{id}")
    @GetMapping("seckill/{id}")  // 注意为了测试限流效果,这里直接改成了Get请求方式,直接用网页刷新就请求了  http://127.0.0.1:8081/voucher-order/seckill/1
    @RateLimiter(
        key = "coupon:seckill:",
        window = 10,
        limit = 5,
        message = "秒杀活动太火爆，请稍后再试",
        type = RateLimiter.LimitType.METHOD
    )
    public Result seckillVoucher(@PathVariable("id") Long voucherId) {
        // return voucherOrderService.seckillVoucher(voucherId);
        return Result.ok();   // 为了测试限流效果,就不执行内部逻辑了,如果没有被限流就直接返回成功
    }
}
```

**这里设置的参数的意思是 在window=10秒窗口时间内，限制访问次数是limit=5次，若10秒内超过5次则会限流(即限制访问)，滑动窗口的方式限流**

**正常情况返回：**

<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1771390842579-fc043e0c-1002-490b-8111-f3f080144b43.png)

**若被限流则会返回：**

<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1771390843110-5b61b5c0-0f8f-4595-9a28-e9431159174d.png)

**日志打印：**

<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1771390843154-94304d3e-05bc-4131-af90-b1e72a764049.png)

**Redis中ZSet记录的数据：**

<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1771390843181-22c12d37-1629-4dfd-b5d8-c1aee708f81a.png)

### 4.3 **限流维度**
限流维度的不同，本质上就是Redis的Key的构造。

<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1771390843167-cbad2eb5-0dc0-44e3-863a-82b409e1e563.png)

