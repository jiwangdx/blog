---
title: 01. 动态规划
article: false
category:
  - 项目
  - 《优享生活圈》
date: 2026-02-15
---
## 一、背包问题

### （一）0-1背包
:::info 0-1背包问题
有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 Vi，价值是 Wi。

求解将哪些物品装入背包，可使这些物品的**总体积不超过背包容量**，且总价值最大。输出最大价值。
:::

![](https://jiwang.cc.cd/PicGo/1770310365758-6bfaab6e-7929-4ff7-a922-40c2051999f5.jpeg)

> j 不是剩余容量，而是我们正在计算的假想容量
>
> DP在同时计算所有可能的情况：从容量0到容量V的每一个可能性
>
> dp[i][j] 回答的是："如果给你一个容量j的空背包，用前i个物品，最多能装多少价值？"
>
> 检查 j >= volumes[i] 是问："这个空背包能单独装下第i个物品吗？" 如果能装下，剩下的容量就由前i-1个物品构造最优解
>

```java
/**
 * 二维DP解法（更直观，方便理解）
 * @param N 物品数量
 * @param V 背包容量
 * @param volumes 物品体积数组，长度为N+1，索引从1开始
 * @param values 物品价值数组，长度为N+1，索引从1开始
 * @return 最大价值
 */
public static int knapsack2D(int N, int V, int[] volumes, int[] values) {
    // dp[i][j]表示前i个物品，容量为j的背包能获得的最大价值
    int[][] dp = new int[N + 1][V + 1];// 能取到int[N][V]

    // dp[0][0~V] 已经全部都是0了,一个物品都不用那得到的最大价值肯定是0
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= V; j++) {
            // 不选第i个物品，那当前的值就等于只考虑前i-1个物品的情况
            dp[i][j] = dp[i - 1][j];
            // 如果能选第i个物品(装得下)，比较选和不选哪个价值更大
            // 选了当前，那当前价值肯定是加上的，并且要意识到，我这个如果取到了最优，
            // 那子问题肯定也是最优的，那么我就可以用前i-1的最优解+当前物品的价值
            if (j >= volumes[i]) {
                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - volumes[i]] + values[i]);
            }
        }
    }

    return dp[N][V];
}
```

#### 降维可行性
状态转移只依赖上一行的两个位置

所以可以用一维数组不断覆盖更新

#### 倒序必要性
计算f[j]时需要用到f[j-v[i]]

必须保证f[j-v[i]]是未被本轮更新的旧值

只有从后往前遍历才能保证这一点

#### 物理意义
<font style="color:#DF2A3F;">一维数组dp[j]</font>表示：考虑完前i个物品，容量为j的最大价值

每次处理新物品时，<font style="background-color:#FBDE28;">从后往前更新</font>，确保每个物品最多被选一次

```java
/**
 * 一维DP解法（空间优化版）
 * @param N 物品数量
 * @param V 背包容量
 * @param volumes 物品体积数组，长度为N+1，索引从1开始
 * @param values 物品价值数组，长度为N+1，索引从1开始
 * @return 最大价值
 */
public static int knapsack1D(int N, int V, int[] volumes, int[] values) {
    // dp[j]表示容量为j的背包能获得的最大价值
    int[] dp = new int[V + 1];

    for (int i = 1; i <= N; i++) {
        
        // 注意：必须从V到volumes[i]倒序遍历，确保每个物品只使用一次
        for (int j = V; j >= volumes[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - volumes[i]] + values[i]);
        }
    }

    return dp[V];
}
```

对于`dp[j] = Math.max(dp[j], dp[j - volumes[i]] + values[i])`

等号左边的 dp[j]（新值），是我们要更新的值。在赋值完成后，它代表考虑完当前物品i后，容量为j的最大价值。

等号右边的第一个 dp[j]（旧值），是还没被更新的旧值，它代表还没考虑当前物品i时，容量为j的最大价值，也就是 dp[i-1][j]。

### （二）完全背包
:::info 完全背包问题
有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。

第 i 种物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。  
输出最大价值。

:::

![](https://jiwang.cc.cd/PicGo/1770309946665-8a5e505f-8a52-41e8-b25c-d5f38a4486cb.jpeg)

```java
/**
 * 完全背包二维DP解法
 * @param N 物品数量
 * @param V 背包容量
 * @param volumes 物品体积数组，长度为N+1，索引从1开始
 * @param values 物品价值数组，长度为N+1，索引从1开始
 * @return 最大价值
 */
public static int completeKnapsack2D(int N, int V, int[] volumes, int[] values) {
    // dp[i][j]表示前i种物品，容量为j的背包能获得的最大价值
    int[][] dp = new int[N + 1][V + 1];
    
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= V; j++) {
            
            // 可选多个，k表示选多少个第i种物品
            for (int k = 0; k * volumes[i] <= j; k++) {
                dp[i][j] = Math.max(dp[i][j], 
                                   dp[i - 1][j - k * volumes[i]] + k * values[i]);
            }
        }
    }
    
    return dp[N][V];
}
```

#### 如何优化
<!-- 这是一张图片，ocr 内容为： -->
![](https://jiwang.cc.cd/PicGo/1770310854437-bf2e4ea2-c24f-4e10-ae69-0e01b1b619ca.png)

```java
/**
 * 完全背包二维DP优化解法
 * 利用状态转移优化掉第三重循环
 */
public static int completeKnapsack2DOptimized(int N, int V, int[] volumes, int[] values) {
    int[][] dp = new int[N + 1][V + 1];
    
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= V; j++) {
            dp[i][j] = dp[i - 1][j];
            
            // 优化：当容量足够时，可以直接考虑选或不选
            if (j >= volumes[i]) {
                // 注意这里是dp[i][j - volumes[i]]，不是dp[i-1][j - volumes[i]]
                dp[i][j] = Math.max(dp[i][j], dp[i][j - volumes[i]] + values[i]);
            }
        }
    }
    
    return dp[N][V];
}
```

#### 转一维
```java
/**
 * 完全背包一维DP解法
 * @param N 物品数量
 * @param V 背包容量
 * @param volumes 物品体积数组，长度为N+1，索引从1开始
 * @param values 物品价值数组，长度为N+1，索引从1开始
 * @return 最大价值
 */
public static int completeKnapsack1D(int N, int V, int[] volumes, int[] values) {
    // dp[j]表示容量为j的背包能获得的最大价值
    int[] dp = new int[V + 1];
    
    // 完全背包核心：正序遍历
    for (int i = 1; i <= N; i++) {
        // 与01背包的唯一区别：这里是正序遍历，因为有重复选的情况
        for (int j = volumes[i]; j <= V; j++) {
            dp[j] = Math.max(dp[j], dp[j - volumes[i]] + values[i]);
        }
    }
    
    return dp[V];
}
```

### （三）多重背包
每个物品有Si个

### （四）分组背包
一组里边只能选一个



