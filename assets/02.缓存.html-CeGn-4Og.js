import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,d as n,o as a}from"./app-BVgJPCaJ.js";const r={};function o(i,e){return a(),s("div",null,[...e[0]||(e[0]=[n('<h1 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存"><span>缓存</span></a></h1><ul><li><strong>缓存优化</strong>：使用逻辑过期方案防止 Redis 热点 Key 的缓存击穿问题；使用缓存空值方案解决 Redis Key 的缓存穿透问题；</li><li><strong>数据一致性</strong>：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性；</li><li><strong>多级缓存</strong>：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redis 压力；</li></ul><h1 id="一、缓存击穿" tabindex="-1"><a class="header-anchor" href="#一、缓存击穿"><span>一、缓存击穿</span></a></h1><p>是这样的，我先说一下背景</p><h2 id="a-背景阐述" tabindex="-1"><a class="header-anchor" href="#a-背景阐述"><span>a. 背景阐述</span></a></h2><p><strong>对于平台的准点开放、限时的一些活动信息 或者 热搜榜单，它们是一个热点数据</strong>，在活动上线之前，我们需要提前预热：将其存入 Redis 中进行缓存，目的是提高系统的响应速度，降低数据库的访问压力。</p><h2 id="b-问题剖析" tabindex="-1"><a class="header-anchor" href="#b-问题剖析"><span>b. 问题剖析</span></a></h2><p>针对<strong>高并发场景的热点数据存入 Redis 缓存</strong>，那么我们需要考虑的很重要的一个问题是：缓存击穿的问题</p><p>如果缓存的热点数据的TTL失效过期的瞬间，有大量的请求访问，</p><p>那么大量请求到达数据库，<strong>导致数据库瞬时压力过大甚至可能崩溃</strong>。</p><h2 id="c-方案构思" tabindex="-1"><a class="header-anchor" href="#c-方案构思"><span>c. 方案构思</span></a></h2><p>因此需要解决缓存击穿的问题，我了解到两种解决方案：一是使用互斥锁。二是使用逻辑过期。</p><p><strong>我先说一下<strong><strong>互斥锁</strong></strong>的方案是这样的：</strong></p><p>当缓存失效时，有大量请求都会去访问数据库，希望获取数据且重新建立缓存再返回给用户数据。<strong>但其实只需要一个请求对应的线程去访问数据库，重新建立起缓存即可</strong>，大量的请求去访问数据库重建缓存给数据库带来瞬时压力过大是不必要的。</p><p>所以在请求进入后，若缓存不存在，那么需要尝试获取互斥锁，大量的请求中，只有一个线程获取锁成功，由这个线程去查询数据库，重新建立缓存，而其他的请求线程获取锁失败，都休眠一小段时间后不断重试获取缓存数据返回。</p><p><strong>这个互斥锁的方案，最终只有一个线程去访问数据库，降低了数据库的访问压力，解决了缓存击穿的问题，但是其他的线程需要等待，性能受到影响，对于外界可能表现出一些不可用或者延迟的现象，但是保证了强一致性。</strong></p><p><strong>而<strong><strong>逻辑过期</strong></strong>的方案是这样的：</strong></p><p>针对热点数据我们<strong>不设置TTL</strong>，也就是说Redis Key永不失效，而是在Redis的Value数据中新增一个属性存储过期时间字段。</p><p>那么在获取key时需要检查过期时间字段，判断是否过期，如果发现过期，则尝试获取互斥锁，大量的请求中，只有一个线程获取锁成功，由这个线程去开启一个独立线程去查询数据库重建缓存，而本线程就直接返回Redis中的旧数据。而其他的请求线程获取锁失败，都返回Redis中的旧数据。</p><p><strong>这个逻辑过期的方案，最终也是只有一个线程去访问数据库，降低了数据库的访问压力，解决了缓存击穿的问题，并且线程无需等待，性能比较好，保证了服务的可用性，但是部分请求返回了Redis的旧数据，没有保证一致性</strong></p><p>所以这两个方案的对比，其实就是 <strong>可用性和一致性的抉择 (CAP定理)</strong> ：</p><ul><li>互斥锁保证了一致性，牺牲了可用性；</li><li>逻辑过期保证了可用性，而牺牲了一致性</li></ul><p><strong>针对这个(活动信息)或(热搜榜单)，它其实是一种社交媒体类型的数据，对于一致性的要求并不是强一致性</strong></p><p><strong>最终我为了保证服务的可用性，选择了使用逻辑过期的方案来解决缓存击穿问题。</strong></p><p>在测试阶段，(手动修改数据库中的数据，使得Redis和MySQL数据不一致)，然后等到Redis中的数据逻辑上过期后，使用 Jmeter 进行压力测试，在5s内5000个线程并发请求，QPS是1000，查看日志可以发现只有一次查询数据库重建缓存的过程，<strong>证明在高并发的场景下，没有让所有的请求打到数据库，成功使用逻辑过期方案解决缓存击穿问题</strong>。缺点就是在缓存尚未重建完毕时，前面一小部分的请求(大概200ms是缓存重建的耗时)获取到的是旧的Redis数据，后面所有的请求获取到的是正确的数据。</p><h2 id="d-复盘总结" tabindex="-1"><a class="header-anchor" href="#d-复盘总结"><span>d. 复盘总结</span></a></h2><p>所以总结一下，这是一个针对于热点数据、存在高并发请求的场景下的 存入Redis缓存，并且解决缓存击穿问题的一个工作内容。我考虑了常见的两种解决方案，最终<strong>根据应用场景</strong>选择了逻辑过期的方案解决。</p><h2 id="衍生问题" tabindex="-1"><a class="header-anchor" href="#衍生问题"><span>衍生问题</span></a></h2><ol><li><h3 id="你说根据应用场景选择逻辑过期的方案解决缓存击穿-那你觉得什么场景才用互斥锁解决呢" tabindex="-1"><a class="header-anchor" href="#你说根据应用场景选择逻辑过期的方案解决缓存击穿-那你觉得什么场景才用互斥锁解决呢"><span><strong>你说根据应用场景选择逻辑过期的方案解决缓存击穿，那你觉得什么场景才用互斥锁解决呢？</strong></span></a></h3></li></ol><p>**答：**我认为是分业务场景的，例如金融类的业务场景，是要求强一致性的，那么才会使用互斥锁方案，而本项目中其实是一个社交媒体类型的业务场景，所以并不要求强一致性，而选择了服务可用性，采用逻辑过期方案。</p><h1 id="二、数据一致性" tabindex="-1"><a class="header-anchor" href="#二、数据一致性"><span>二、数据一致性</span></a></h1><p><strong>数据一致性</strong>：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性；</p><h2 id="a-背景阐述-1" tabindex="-1"><a class="header-anchor" href="#a-背景阐述-1"><span>a. 背景阐述</span></a></h2><p>把数据存入Redis缓存</p><h2 id="b-问题剖析-1" tabindex="-1"><a class="header-anchor" href="#b-问题剖析-1"><span>b. 问题剖析</span></a></h2><p>但MySQL中的数据是会修改的，为了保证Redis和MySQL的数据一致性</p><h2 id="c-方案构思-1" tabindex="-1"><a class="header-anchor" href="#c-方案构思-1"><span>c. 方案构思</span></a></h2><p>本项目中采用的方案是，在更新数据库后，再同步删除缓存，若删除缓存失败，则发送一个消息到Kafka中，消息中携带上要删除的key的信息，同时需要启动Kafka消费者，消费者接收到消息后执行缓存删除逻辑。如果删除缓存失败，消息队列的重试机制就可以发挥作用，<strong>梯度重试</strong>的去删除缓存，<strong>尽量保证</strong>数据的最终一致性。</p><blockquote><p>梯度重试（Exponential Backoff）是一种用于处理失败的重试机制，它会根据重试的次数逐渐增加重试的间隔时间，避免在短时间内频繁地重复操作，从而减少系统的负载和资源消耗。</p></blockquote><ul><li>删除缓存还是更新缓存？ <ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li></ul><h2 id="d-复盘总结-1" tabindex="-1"><a class="header-anchor" href="#d-复盘总结-1"><span>d. 复盘总结</span></a></h2><p>当然保证数据一致性还有很多方案，例如利用Canal订阅Binlog后删除缓存，又例如延迟双删。</p><p>当然上述方法都不能保证MySQL数据和Redis缓存的数据强一致性，只是保证最终一致性</p><p><strong>无论选择哪种方案都需要为缓存设置TTL，作为兜底策略。</strong></p><blockquote><p><strong>&quot;设置过期时间&quot;就像是给缓存加了&quot;自动清理保险&quot;，即使我们主动删除失败，系统也能在一定时间后自我修复，避免永久性的数据不一致。</strong></p></blockquote><h2 id="衍生问题-1" tabindex="-1"><a class="header-anchor" href="#衍生问题-1"><span>衍生问题</span></a></h2><ol><li><h3 id="使用消息队列重试-如果一直失败怎么办" tabindex="-1"><a class="header-anchor" href="#使用消息队列重试-如果一直失败怎么办"><span><strong>使用消息队列重试，如果一直失败怎么办？</strong></span></a></h3></li></ol><p><strong>答：记录失败次数</strong>，程序里检测达到最大重试次数后，<strong>触发告警，人工介入排查原因</strong></p><ol><li><h3 id="为什么是先更新mysql-后删除redis缓存" tabindex="-1"><a class="header-anchor" href="#为什么是先更新mysql-后删除redis缓存"><span><strong>为什么是先更新MySQL，后删除Redis缓存？</strong></span></a></h3></li></ol><p><strong>数据库更新较慢</strong>是问题的根源。<strong>先删除缓存再更新数据库</strong>会导致缓存失效后，高并发请求都去读数据库，可能会读取到过时的数据，造成数据不一致。而<strong>先更新数据库再删除缓存</strong>可以确保数据库中的数据是准确的，减少并发访问时出现超卖等问题。</p><p>比如：当用户下单时，系统如果先更新数据库库存（比如从10减少到9），然后再删除Redis缓存，就算删除缓存失败，库存数据已经正确保存到数据库，后续的请求会从数据库读取到准确的库存，避免超卖问题。</p><p>如果反过来，先删除缓存再更新数据库，万一数据库更新失败，缓存已经不存在，系统就可能出现超卖，因为后续用户还可以购买该商品，尽管实际库存已经为0。</p><blockquote><p>删除缓存的操作是直接在数据库更新后进行，且不返回直到这个操作完成。</p></blockquote><ol><li><h3 id="什么是延迟双删" tabindex="-1"><a class="header-anchor" href="#什么是延迟双删"><span><strong>什么是延迟双删</strong></span></a></h3></li></ol><p>请参考 本文档中的&lt;项目衍生涉及八股参考&gt;——《Redis 缓存与 MySQL 数据一致性》</p><h1 id="三、多级缓存" tabindex="-1"><a class="header-anchor" href="#三、多级缓存"><span>三、多级缓存</span></a></h1><ol><li><strong>多级缓存</strong>：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redis 压力；</li></ol><h2 id="a-背景阐述-2" tabindex="-1"><a class="header-anchor" href="#a-背景阐述-2"><span>a. 背景阐述</span></a></h2><p>对于一些存储在Redis中的过热的key，例如秒杀优惠券的详情页，</p><p>它本身是<strong>更新频率极低的，访问频率很高</strong>的数据。</p><h2 id="b-问题剖析-2" tabindex="-1"><a class="header-anchor" href="#b-问题剖析-2"><span>b. 问题剖析</span></a></h2><p>而Redis单实例性能有上限，单个Redis的压力过大，Redis可能成为系统瓶颈</p><h2 id="c-方案构思-2" tabindex="-1"><a class="header-anchor" href="#c-方案构思-2"><span>c. 方案构思</span></a></h2><p>我的方案是使用<strong>Caffeine本地缓存+Redis缓存</strong>，搭建二级缓存，</p><p>本地缓存将<strong>热 Key 的访问压力分散到各个应用实例的内存中，显著降低Redis的访问压力</strong></p><p>搭建二级缓存架构后，用户的请求流程将会是</p><ul><li>先从本地缓存中获取数据，如果本地缓存有数据则返回数据</li><li>否则从Redis缓存中获取数据。如果Redis缓存中有数据则更新本地缓存，然后将数据返回客户端</li><li>如果Redis缓存没有数据则去数据库查询数据，然后更新Redis缓存，接着再更新本地缓存，最后将数据返回给客户端</li></ul><p>当然使用本地缓存，有一个问题是，当后端服务<strong>集群部署</strong>时，如果数据库的数据有更新的情况，本地缓存的数据和数据库的数据存在不一致的情况，如果要更新/删除本地缓存的数据，因为是集群部署，就要把所有节点的本地缓存的数据都进行更新/删除，此时这个实现稍微有些复杂，例如发送广播消息，所有实例节点监听广播消息，然后在本地缓存更新/删除。</p><p>但是其实可以使用一种更简单的方法，就是我们可以<strong>给本地缓存设置较短时间的TTL</strong>，这样我们可以不用去管本地缓存的数据更新，而是仅依靠TTL，去不断刷新本地缓存的数据。</p><h2 id="d-复盘总结-2" tabindex="-1"><a class="header-anchor" href="#d-复盘总结-2"><span>d. 复盘总结</span></a></h2><p>总结一下，当因为有热Key，导致Redis实例的压力过高时，为了减少Redis的访问压力，并且这个优惠券的详情页数据是极少去更新的，几乎不变的，因此我使用本地缓存进行优化。</p><h2 id="衍生问题-2" tabindex="-1"><a class="header-anchor" href="#衍生问题-2"><span>衍生问题</span></a></h2><ol><li><h3 id="redis单实例压力过大-为什么不搭建redis集群" tabindex="-1"><a class="header-anchor" href="#redis单实例压力过大-为什么不搭建redis集群"><span><em><strong>Redis单实例压力过大，为什么不搭建Redis集群</strong></em></span></a></h3></li></ol><p>**答：**第一考虑成本问题，第二即使搭建了Redis集群，热Key存在于某个Redis实例上，依然会使得单台Redis实例压力过大，除非对该热Key进行分片，分散到不同的Redis实例上，这样实现复杂度又增加了。所以可以选择本地缓存方案，简单。</p><ol><li><h3 id="本地缓存和分布式缓存的区别" tabindex="-1"><a class="header-anchor" href="#本地缓存和分布式缓存的区别"><span><em><strong>本地缓存和分布式缓存的区别？</strong></em></span></a></h3></li></ol><p>本地缓存一般存储更新频率低，访问频率高的数据。</p><blockquote><p><strong>本地缓存</strong>：是单台应用服务器维度的缓存，会占用服务器本身存储空间。假设一个分布式系统有5台应用服务器，那么这5台服务器中的缓存内容是独立且相同的，彼此不相互影响。本地缓存更多的是用来频繁地读，而非写。数据会随着应用程序的重启而丢失</p><p>优点：本地缓存不需要远程网络请求去操作内存空间，没有额外的性能消耗，所以读取速度快。</p><p>缺点：不能进行大数据量存储；应用程序集群部署时，会存在数据更新问题（数据更新不一致）</p><p><strong>分布式缓存</strong>：一种专门做存储的系统（单台服务器或集群）如Redis。只要向其存储一份数据，那么接入该分布式缓存的所有应用服务器可以获取到相同的内容，保证了数据的一致性。举个例子，淘宝商品库存可以放到Redis中，用户在服务器A下了一单库存减少为99，同步更新到Redis，其他用户在服务器B看到的库存也会变成99。</p></blockquote><ul><li>支持大数据量存储：分布式缓存是独立部署的进程，拥有自身独自的内存空间，不需要占用应用程序进程的内存空间，并且还支持横向扩展的集群方式部署，所以可以进行大数据量存储。</li><li>数据不会随着应用程序重启而丢失</li><li>数据集中存储，保证数据的一致性</li><li>数据读写分离，高性能，高可用</li></ul><ol><li><h3 id="本地缓存和数据库数据的数据一致性是怎么保证的" tabindex="-1"><a class="header-anchor" href="#本地缓存和数据库数据的数据一致性是怎么保证的"><span><em><strong>本地缓存和数据库数据的数据一致性是怎么保证的？</strong></em></span></a></h3></li></ol><p>请参考 本文档中的&lt;项目衍生涉及八股参考&gt;——《多级缓存》</p><ol><li><h3 id="有了解过caffeine的实现原理吗" tabindex="-1"><a class="header-anchor" href="#有了解过caffeine的实现原理吗"><span><em><strong>有了解过Caffeine的实现原理吗？</strong></em></span></a></h3></li></ol><p>**答：**Caffeine在设计上注重提高数据访问速度和并发性能。它使用<code>ConcurrentHashMap</code><strong>作为底层存储，并结合</strong>LRU（最近最少使用）<strong>策略来淘汰过期的缓存数据。为了优化并发性能，Caffeine采用了</strong>分段锁（Segment）<strong>和</strong>桶（Bucket）结构，减少线程竞争。</p><p>Count-Min Sketch 与tiny LRU结合使用，优化缓存项的选择和淘汰。传统的 LRU 算法通常基于最近的访问时间进行缓存淘汰，但 <strong>Count-Min Sketch</strong> 使得算法可以根据 <strong>访问频率</strong> 做出更智能的决策，从而优化缓存的有效性。，从而有效地管理缓存条目，并确保热点数据得到优先保留。在写操作上，它采用类似<strong>WAL</strong>（Write-Ahead Logging）的机制，通过多生产者单消费者模式来缓存写入任务，从而提高并发写入的效率。</p><blockquote><p><strong>WAL</strong> 是一种日志机制，确保数据的变更首先记录到日志文件中，然后才被应用到实际的数据存储中，这样可以保证数据的一致性和恢复。</p><p>在 Caffeine 中，<strong><code>writeBuffer</code></strong> 作为缓存写入的缓冲区，数据先进入这个缓冲区，然后在合适的时机批量刷新到内存缓存中，这类似于 WAL 的日志记录，确保缓存写入操作的高效性和一致性。</p></blockquote><table><thead><tr><th>特性</th><th>普通LRU</th><th>TinyLRU</th></tr></thead><tbody><tr><td>内存消耗</td><td>较高（使用双向链表 + HashMap）</td><td>较低（优化的内部结构，减少内存开销）</td></tr><tr><td>数据结构</td><td>双向链表 + HashMap</td><td>单向链表+HashMap</td></tr><tr><td>性能</td><td>稍低（由于双向链表维护前后指针）</td><td>较高（简化的数据结构，减少内存管理复杂性）</td></tr><tr><td>适用场景</td><td>内存较充足的环境，功能完整的缓存系统</td><td>内存敏感的高并发场景，资源有限时</td></tr></tbody></table><blockquote><p>Caffeine 选择使用 <strong>单向链表 + HashMap</strong> 作为 <code>TinyLRU</code> 的实现结构，主要是因为它在 <strong>高并发环境下</strong> 提供了 <strong>内存高效</strong> 和 <strong>操作高效</strong> 的优势。相较于 <strong>传统的双向链表</strong>，这种设计的 <strong>内存占用更少</strong>，且对 <strong>LRU 缓存的管理</strong>足够高效，能够在内存和性能之间做出 <strong>更好的平衡</strong>。对于 Caffeine 这样的高性能缓存库来说，减少内存开销并且保证性能是最重要的目标，因此它将 <strong>单向链表</strong> 作为优化方案。</p></blockquote>',86)])])}const g=t(r,[["render",o]]),h=JSON.parse(`{"path":"/projects/dianping/02.%E7%BC%93%E5%AD%98.html","title":"缓存","lang":"zh-CN","frontmatter":{"title":"缓存","icon":"database","category":["项目","黑马点评"],"tag":["缓存","缓存击穿","数据一致性","多级缓存"],"date":"2026-02-15T00:00:00.000Z","article":false,"description":"缓存 缓存优化：使用逻辑过期方案防止 Redis 热点 Key 的缓存击穿问题；使用缓存空值方案解决 Redis Key 的缓存穿透问题； 数据一致性：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性； 多级缓存：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redi...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"缓存\\",\\"description\\":\\"缓存 缓存优化：使用逻辑过期方案防止 Redis 热点 Key 的缓存击穿问题；使用缓存空值方案解决 Redis Key 的缓存穿透问题； 数据一致性：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性； 多级缓存：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redi...\\"}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/projects/dianping/02.%E7%BC%93%E5%AD%98.html"}],["meta",{"property":"og:site_name","content":"jiwang's blog"}],["meta",{"property":"og:title","content":"缓存"}],["meta",{"property":"og:description","content":"缓存 缓存优化：使用逻辑过期方案防止 Redis 热点 Key 的缓存击穿问题；使用缓存空值方案解决 Redis Key 的缓存穿透问题； 数据一致性：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性； 多级缓存：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redi..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-14T18:22:20.000Z"}],["meta",{"property":"article:tag","content":"多级缓存"}],["meta",{"property":"article:tag","content":"数据一致性"}],["meta",{"property":"article:tag","content":"缓存击穿"}],["meta",{"property":"article:tag","content":"缓存"}],["meta",{"property":"article:published_time","content":"2026-02-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-14T18:22:20.000Z"}]]},"git":{"createdTime":1771093340000,"updatedTime":1771093340000,"contributors":[{"name":"dongjiwang","username":"dongjiwang","email":"1790921341@qq.com","commits":1,"url":"https://github.com/dongjiwang"}]},"readingTime":{"minutes":14.15,"words":4246},"filePathRelative":"projects/dianping/02.缓存.md","excerpt":"\\n<ul>\\n<li><strong>缓存优化</strong>：使用逻辑过期方案防止 Redis 热点 Key 的缓存击穿问题；使用缓存空值方案解决 Redis Key 的缓存穿透问题；</li>\\n<li><strong>数据一致性</strong>：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性；</li>\\n<li><strong>多级缓存</strong>：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redis 压力；</li>\\n</ul>\\n<h1>一、缓存击穿</h1>\\n<p>是这样的，我先说一下背景</p>","autoDesc":true}`);export{g as comp,h as data};
