import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,d as k,a as i,e as l,b as t,w as a,f as r,r as d,o}from"./app-DJn-akYj.js";const h={},g={class:"hint-container warning"},u={class:"hint-container warning"},y={class:"hint-container caution"};function B(A,s){const n=d("font");return o(),e("div",null,[s[173]||(s[173]=k('<h2 id="一、秒杀防超卖和一人一单" tabindex="-1"><a class="header-anchor" href="#一、秒杀防超卖和一人一单"><span>一、秒杀防超卖和一人一单</span></a></h2><ul><li><strong>秒杀防超卖和一人一单</strong>：使用 Redis 存储库存和订单信息，Lua 判断用户下单资格，保证库存不超卖和一人一单；</li></ul><h3 id="_1-1-问题解决" tabindex="-1"><a class="header-anchor" href="#_1-1-问题解决"><span>1.1 问题解决</span></a></h3><div class="hint-container info"><p class="hint-container-title">背景</p><p>平台上商家可以发布一些折扣力度很大的优惠券，这种优惠券是某个时间点限量供应的，所以在这个时间点会有比较大的流量进入，也就是一个秒杀场景，必须要保证的是在高并发的情况下，防止库存超卖，以及这种优惠券是限制每位用户只能购买一次。即防库存超卖和一人一单。</p><p>要达到目的，只需要做好校验，校验用户是否有资格下单，如果库存不足或者用户已经下过单，则此时可认为用户是没有资格下单，拒绝请求。反之用户有资格下单则进行后续流程。</p></div><p>那我们如何做这个校验呢？首先很容易想到的方案是：</p>',5)),i("ul",null,[i("li",null,[s[2]||(s[2]=l("针对一人一单，去数据库查用户是否已经下过单，如果查到用户对应优惠券的订单，说明已经下过单，则拒绝请求。这个过程中为了防止",-1)),t(n,{style:{color:"rgb(222,120,2)"}},{default:a(()=>[...s[0]||(s[0]=[l("同一个用户",-1)])]),_:1}),s[3]||(s[3]=l("发起多个下单请求，还需要使用",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[1]||(s[1]=[l("分布式锁",-1)])]),_:1}),s[4]||(s[4]=l("保证并发安全。",-1))]),s[5]||(s[5]=i("li",null,"针对库存是否超卖，只需要在减库存时，即 update 库存的时候应该加上 where 库存 > 0 , 自然不会超卖。",-1))]),i("div",g,[s[7]||(s[7]=i("p",{class:"hint-container-title"},"注意",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[6]||(s[6]=[l("但是",-1)])]),_:1}),s[8]||(s[8]=l("在高并发的情况下，大量的请求 查询数据库和尝试更新数据（update是需要给记录加锁的，存在锁竞争），并且还使用了分布式锁，使得整个秒杀业务的性能受到很大影响。",-1)),s[9]||(s[9]=i("p",null,"使用 JMeter 测试 QPS 1000，200个库存的情况下，平均响应时间是500ms，比较慢。",-1))]),s[174]||(s[174]=i("p",null,[i("strong",null,"因此需要进行优化，")],-1)),i("p",null,[s[11]||(s[11]=l("第一，我不想因为 ",-1)),t(n,{style:{color:"rgb(222,120,2)"}},{default:a(()=>[...s[10]||(s[10]=[l("下单资格的判断",-1)])]),_:1}),s[12]||(s[12]=l(" 让MySQL数据库去承载高并发的查询和更新，那我觉得可以在Redis中完成用户下单资格的判断。",-1))]),i("p",null,[s[14]||(s[14]=l("第二，既然使用了Redis，那么我联想到 Lua 正好是原子性的，可以解决一人一单的并发安全问题，也就不再需要使用",-1)),t(n,{style:{color:"rgb(222,120,2)"}},{default:a(()=>[...s[13]||(s[13]=[l("分布式锁",-1)])]),_:1}),s[15]||(s[15]=l("。",-1))]),i("p",null,[s[17]||(s[17]=l("也就是说我可以",-1)),t(n,{style:{"background-color":"#FBDE28"}},{default:a(()=>[...s[16]||(s[16]=[l("把下单资格的判断 （防止库存超卖和一人一单） 在Redis的Lua脚本中",-1)])]),_:1}),s[18]||(s[18]=l("完成",-1))]),i("p",null,[s[20]||(s[20]=l("那么前提呢？就需要把 优惠券 ",-1)),t(n,{style:{color:"rgb(222,120,2)"}},{default:a(()=>[...s[19]||(s[19]=[l("库存信息和订单信息",-1)])]),_:1}),s[21]||(s[21]=l(" 存储Redis里",-1))]),i("ul",null,[i("li",null,[s[30]||(s[30]=l("存储在Redis的优惠券",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[22]||(s[22]=[l("库存信息",-1)])]),_:1}),s[31]||(s[31]=l("包括： 优惠券的库存、优惠券开始秒杀时间和结束秒杀时间 ",-1)),i("ul",null,[s[28]||(s[28]=i("li",null,[i("code",null,'使用 <font style="background-color:#81DFE4;">String</font> 即可，key：业务前缀+优惠券的ID value：优惠券库存信息')],-1)),s[29]||(s[29]=i("li",null,"当想要校验库存是否充足时，只需要判断Redis中的库存是否大于0，",-1)),i("li",null,[s[24]||(s[24]=l("同时 当已判断用户有下单资格后，下单成功，",-1)),t(n,{style:{color:"rgb(222,120,2)"}},{default:a(()=>[...s[23]||(s[23]=[l("在Redis中预减库存",-1)])]),_:1})]),i("li",null,[s[26]||(s[26]=l("这样，只要Redis的库存减到0，后续的请求都会被拒绝，库存一定不会超卖（",-1)),t(n,{style:{color:"rgb(222,120,2)"}},{default:a(()=>[...s[25]||(s[25]=[l("Redis单线程执行",-1)])]),_:1}),s[27]||(s[27]=l("）",-1))])])]),i("li",null,[s[33]||(s[33]=l("存储在Redis的",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[32]||(s[32]=[l("订单信息",-1)])]),_:1}),s[34]||(s[34]=l("：其实只需要记录 优惠券被哪些用户购买过 ",-1)),s[35]||(s[35]=i("ul",null,[i("li",null,[i("code",null,'使用 <font style="background-color:#81DFE4;">Set</font> 数据类型即可，key是：业务前缀+优惠券的ID value是：所有购买过该优惠券的用户ID')]),i("li",null,"当想要校验一人一单时，只需要判断对应优惠券key的value中是否已有该用户ID（SISMEMBER），如果已有说明购买过，拒绝请求"),i("li",null,"同时，当判断用户有下单资格后，下单成功，也需要将该用户ID记录到该key的集合中。")],-1))])]),t(n,{style:{color:"#DF2A3F"}},{default:a(()=>[...s[36]||(s[36]=[l("修改后",-1)])]),_:1}),s[175]||(s[175]=l("：JMeter 测试 QPS 1000，200个库存，平均响应时间是176ms，性能提高64.8%",-1)),s[176]||(s[176]=i("h3",{id:"_1-2-衍生思考",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_1-2-衍生思考"},[i("span",null,"1.2 衍生思考")])],-1)),s[177]||(s[177]=i("h4",{id:"_1-如果是一人两单或一人n单呢-用set还能做到吗",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_1-如果是一人两单或一人n单呢-用set还能做到吗"},[i("span",null,[l("（1）"),i("em",null,[i("strong",null,"如果是一人两单或一人N单呢？用Set还能做到吗？")])])])],-1)),s[178]||(s[178]=i("p",null,'Set 数据类型 只能记录用户 "是否购买过"，无法记录 "购买了几次"。因此可以使用 Hash',-1)),i("p",null,[s[38]||(s[38]=l("每个优惠券创建一个Hash结构",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[37]||(s[37]=[l(" {优惠券ID，（用户ID，单量）}",-1)])]),_:1})]),s[179]||(s[179]=k('<ul><li>Key 是：业务前缀+优惠券的ID</li><li>Field：用户ID 作为字段名</li><li>Value：该用户对该优惠券的当前已购买数量（甚至可以扩展，也记录下订单号、支付状态）</li></ul><p>此时只需要校验Value用户购买的数量即可完成一人N单的需求</p><h4 id="_2-如果某个券允许购买的用户量很大-用set或hash存储该券的订单数据-会不会造成大key" tabindex="-1"><a class="header-anchor" href="#_2-如果某个券允许购买的用户量很大-用set或hash存储该券的订单数据-会不会造成大key"><span>（2）<em><strong>如果某个券允许购买的用户量很大，用Set或Hash存储该券的订单数据，会不会造成大Key？</strong></em></span></a></h4><p>**答：**大Key是指 Value体积过大（如String类型 &gt; 2MB，Hash/List元素&gt;5000个）的Key</p><p>从业务上来讲，一般情况下，</p><p>一次秒杀活动中，针对单个优惠券，不会提供大量的库存，即存在大Key的可能性较小</p>',6)),i("p",null,[s[40]||(s[40]=l("但如果真的有某个券的库存很多，导致产生大Key，解决的方案是",-1)),t(n,{style:{color:"rgb(222,120,2)"}},{default:a(()=>[...s[39]||(s[39]=[l("拆分大key为多个小key",-1)])]),_:1}),s[41]||(s[41]=l("。",-1))]),i("p",null,[s[43]||(s[43]=l("按",-1)),t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[42]||(s[42]=[l("时间或商品ID",-1)])]),_:1}),s[44]||(s[44]=l("拆分大 Key：避免将所有库存和购买记录都存储在一个 Redis Key 中。",-1))]),s[180]||(s[180]=i("p",null,[i("strong",null,"Redis 集群"),l("：如果单一Redis 实例无法承载大量数据，可以使用 Redis Cluster 进行水平扩展。")],-1)),i("p",null,[s[46]||(s[46]=i("strong",null,"过期策略",-1)),s[47]||(s[47]=l("：为 Redis 中的数据设置",-1)),t(n,{style:{color:"rgb(222,120,2)"}},{default:a(()=>[...s[45]||(s[45]=[l("合理的过期时间",-1)])]),_:1}),s[48]||(s[48]=l("，避免过期数据积压。",-1))]),s[181]||(s[181]=k('<h2 id="二、秒杀流程优化" tabindex="-1"><a class="header-anchor" href="#二、秒杀流程优化"><span>二、秒杀流程优化</span></a></h2><h3 id="_2-1-问题解决" tabindex="-1"><a class="header-anchor" href="#_2-1-问题解决"><span>2.1 问题解决</span></a></h3><div class="hint-container info"><p class="hint-container-title">背景</p><p>平台上商家可以发布一些折扣力度很大的优惠券，这种优惠券是某个时间点限量供应的，所以在这个时间点会有比较大的流量进入，也就是一个秒杀场景，在判断完毕用户有资格下单后，就会扣减MySQL的库存、生成订单。</p><p>在秒杀这个高并发的场景下，扣减库存、生成订单，其实是两次MySQL数据库操作，使得整个秒杀业务的性能受到很大影响。</p></div>',3)),i("p",null,[s[50]||(s[50]=l("之前是一个同步流程，",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[49]||(s[49]=[l("判断资格-->扣减库存-->生成订单",-1)])]),_:1}),s[51]||(s[51]=l("。",-1))]),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[52]||(s[52]=[l("其实在redis层，判断完用户有资格下单 (库存不超卖、一人一单) 后，就意味着用户下单成功、秒杀成功",-1)])]),_:1}),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[53]||(s[53]=[l("至于MySQL的库存扣减和订单生成，完全可以",-1)])]),_:1}),t(n,{style:{color:"rgb(216,57,49)","background-color":"#81DFE4"}},{default:a(()=>[...s[54]||(s[54]=[l("异步",-1)])]),_:1}),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[55]||(s[55]=[l("的来做",-1)])]),_:1}),s[182]||(s[182]=l("。",-1)),i("p",null,[s[57]||(s[57]=l("我们可以在判断用户有下单资格后，发送一个",-1)),t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[56]||(s[56]=[l("Kafka",-1)])]),_:1}),s[58]||(s[58]=l("消息，另外启动一个Kafka消费者监听消息，在消费者的逻辑内去扣减库存、生成订单。通过",-1)),s[59]||(s[59]=i("code",null,'<font style="color:rgb(216,57,49);">同步变异步</font>',-1)),s[60]||(s[60]=l("，提高秒杀场景的并发性能。",-1))]),i("p",null,[s[62]||(s[62]=l("并且，",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[61]||(s[61]=[l("如果以后业务有所扩展",-1)])]),_:1}),s[63]||(s[63]=l("，例如用户下单成功后，需要 额外的做一些事情(例如通知用户下单成功)，也可以放到Kafka消费者里去做，而不是不断的新增在秒杀的同步流程中。",-1))]),s[183]||(s[183]=i("h3",{id:"_2-2-衍生思考",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_2-2-衍生思考"},[i("span",null,"2.2 衍生思考")])],-1)),s[184]||(s[184]=i("h4",{id:"_1-避免重复消费",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_1-避免重复消费"},[i("span",null,[l("（1）"),i("em",null,[i("strong",null,"避免重复消费")])])])],-1)),i("p",null,[i("strong",null,[t(n,{style:{"background-color":"rgb(246,241,254)"}},{default:a(()=>[...s[64]||(s[64]=[l("幂等性",-1)])]),_:1})]),t(n,{style:{"background-color":"rgb(246,241,254)"}},{default:a(()=>[...s[65]||(s[65]=[l("（Idempotence）这个概念其实很简单，它指的是“",-1)])]),_:1}),i("strong",null,[t(n,{style:{"background-color":"rgb(246,241,254)"}},{default:a(()=>[...s[66]||(s[66]=[l("无论你做多少次相同的操作，结果都是一样的",-1)])]),_:1})]),t(n,{style:{"background-color":"rgb(246,241,254)"}},{default:a(()=>[...s[67]||(s[67]=[l("”。",-1)])]),_:1})]),i("p",null,[s[69]||(s[69]=l("启用 Kafka ",-1)),t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[68]||(s[68]=[l("生产者",-1)])]),_:1}),s[70]||(s[70]=l("幂等性",-1))]),s[185]||(s[185]=i("p",null,"Kafka 生产者可以通过启用幂等性来避免消息重复发送：",-1)),s[186]||(s[186]=i("p",null,[l("当生产者发送消息时，Kafka 会为每条消息分配一个 "),i("strong",null,"唯一的序列号"),l("。当消息被重试时，Kafka 会通过消息的序列号来判断是否是重复的。如果消息的序列号较小（即是一个已处理过的消息），Kafka 会丢弃该消息，避免重复消费。")],-1)),i("p",null,[s[72]||(s[72]=l("**",-1)),t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[71]||(s[71]=[l("消费者",-1)])]),_:1}),s[73]||(s[73]=l("**端实现幂等性/去重",-1))]),i("p",null,[s[75]||(s[75]=l("Kafka 本身是",-1)),t(n,{style:{color:"#DF2A3F"}},{default:a(()=>[...s[74]||(s[74]=[l(" at-least-once ",-1)])]),_:1}),s[76]||(s[76]=l("语义，因此消费者必须保证幂等。我采用数据库唯一索引保证幂等性。在生成订单时提前生成全局唯一 orderId，并在订单表对 orderId 建立唯一索引。消费时直接 insert，如果成功说明首次消费；如果触发唯一索引异常，我会捕获异常并认为是幂等命中，直接 ack，从而保证重复消费不会影响系统状态。这种方式简单可靠，是生产环境中最常见的做法。",-1))]),s[187]||(s[187]=i("div",{class:"hint-container warning"},[i("p",{class:"hint-container-title"},"注意"),i("p",null,"如果业务量极大，考虑使用 Redis 做第一层幂等过滤，数据库唯一索引做最终兜底，形成“双层幂等保护”。")],-1)),s[188]||(s[188]=i("h4",{id:"_2-kafka怎么保证消息不丢失的",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_2-kafka怎么保证消息不丢失的"},[i("span",null,[l("（2）"),i("em",null,[i("strong",null,"Kafka怎么保证消息不丢失的？")])])])],-1)),i("p",null,[i("strong",null,[t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[77]||(s[77]=[l("生产者",-1)])]),_:1})]),s[78]||(s[78]=l("：发送消息不丢失",-1))]),i("p",null,[s[80]||(s[80]=i("strong",null,"回调机制（Callback）",-1)),s[81]||(s[81]=l("：生产者通过",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[79]||(s[79]=[l("带回调方法的 API ",-1)])]),_:1}),s[82]||(s[82]=l("发送消息，回调函数会告知消息是否成功发送。如果消息发送失败，生产者可以在回调中进行异常处理。例如，可以将失败的消息存储到本地磁盘或远程数据库，以便后续重新发送。",-1))]),s[189]||(s[189]=i("p",null,[i("code",null,"acks"),l(" 参数："),i("code",null,'<font style="color:rgb(216,57,49);">acks=-1</font>'),l(" 表示消息必须在被写入到主副本（Leader）以及所有副本（Follower）后，才返回响应。这个设置确保即使某个副本宕机，消息仍然能够被保留。")],-1)),s[190]||(s[190]=i("p",null,[i("code",null,"retries 参数：设置消息发送失败后的最大重试次数（例如，"),l("retries=3`），通过自动重试确保在网络或 Broker 故障时尽量减少消息丢失的风险。")],-1)),i("p",null,[i("strong",null,[t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[83]||(s[83]=[l("Broker",-1)])]),_:1})]),s[84]||(s[84]=l("：保存消息不丢失",-1))]),s[191]||(s[191]=i("p",null,[i("strong",null,"副本机制"),l("：Kafka 通过设置分区副本数（"),i("code",null,"replication.factor > 1"),l("）来确保数据持久化。如果某个副本的 Leader 挂掉，其他副本会选举出新的 Leader，确保消息的可靠性和高可用性。")],-1)),i("p",null,[s[86]||(s[86]=i("strong",null,"日志存储",-1)),s[87]||(s[87]=l("：Kafka 将所有消息按分区存储为日志文件，消息会追加写入磁盘直到被删除。Kafka 的这种",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[85]||(s[85]=[l("持久化机制",-1)])]),_:1}),s[88]||(s[88]=l("使得数据不会因为 Broker 重启或失败而丢失。",-1))]),i("p",null,[i("strong",null,[t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[89]||(s[89]=[l("消费者",-1)])]),_:1})]),s[90]||(s[90]=l("：确保不漏消费消息",-1))]),s[192]||(s[192]=k("<p>Kafka 将每个 <strong>Topic</strong> 划分为多个 <strong>Partition（分区）</strong>，每个分区内的消息都是有序的。每条消息在分区内都会被分配一个唯一的 <strong>offset</strong>，从 <code>0</code> 开始递增。例如，第一个消息的 offset 为 <code>0</code>，第二个为 <code>1</code>，依此类推。</p>",1)),i("p",null,[s[93]||(s[93]=i("strong",null,"手动提交 offset",-1)),s[94]||(s[94]=l("：需要",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[91]||(s[91]=[l("禁用 自动提交消息偏移量 的机制",-1)])]),_:1}),s[95]||(s[95]=l("。因为在业务逻辑未完成时，可能会导致 offset 提交过早，导致消息丢失。手动提交 offset 可以确保只有在业务逻辑成功处理后，才更新消费进度，",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[92]||(s[92]=[l("避免漏消费",-1)])]),_:1}),s[96]||(s[96]=l("。",-1))]),i("blockquote",null,[s[103]||(s[103]=k("<p><strong>Offset</strong> 在 Kafka 中指的是 <strong>分区内消息的位移</strong>，即某个消费者在 Kafka 分区中消费到的消息的位置。</p><p><strong>一个业务过程可能会涉及多条消息，在这种情况下，正确的 offset 提交 就变得非常重要。</strong></p><p><strong>Topic</strong>：消息的主题或类别，相当于一个大的消息队列。</p><p><strong>Partition</strong>：是对 <strong>Topic</strong> 的划分，每个 <strong>Partition</strong> 都是一个独立的队列。Kafka 通过分区来提高并发处理和存储的能力。</p><p><strong>消费者组（Consumer Group）</strong> 是 Kafka 中的一个重要概念，它将多个消费者组织在一起，组成一个逻辑上的消费单元。</p>",5)),i("p",null,[i("strong",null,[t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[97]||(s[97]=[l("一个分区",-1)])]),_:1}),s[100]||(s[100]=i("strong",null,[i("strong",null,"在")],-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[98]||(s[98]=[l("一个消费者组内",-1)])]),_:1}),s[101]||(s[101]=i("strong",null,[i("strong",null,"只能由一个消费者来消费"),l("，以")],-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[99]||(s[99]=[l("确保每条消息只被消费一次",-1)])]),_:1})]),s[102]||(s[102]=l("。",-1))]),s[104]||(s[104]=i("p",null,[i("strong",null,"一个消费者可以消费多个分区"),l("，但 "),i("strong",null,"每个分区只能由一个消费者消费"),l("。")],-1)),s[105]||(s[105]=i("p",null,[l("如果 "),i("strong",null,"消费者数少于分区数"),l("，一个消费者可能会消费多个分区。")],-1)),s[106]||(s[106]=i("p",null,[l("如果 "),i("strong",null,"消费者数多于分区数"),l("，多余的消费者会处于空闲状态。")],-1))]),s[193]||(s[193]=i("h4",{id:"_3-kafka消息堆积怎么办",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_3-kafka消息堆积怎么办"},[i("span",null,[l("（3）"),i("em",null,[i("strong",null,"Kafka消息堆积怎么办？")])])])],-1)),i("p",null,[i("strong",null,[t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[107]||(s[107]=[l("消费者端优化",-1)])]),_:1})])]),s[194]||(s[194]=i("p",null,[l("消费者"),i("strong",null,"消费速度太慢"),l("，导致消息积压，可以优化消费者代码逻辑当消费者数量少于partition分区数量时，可以"),i("strong",null,"增加消费者数量"),l("（但不能超过partition的数量）")],-1)),i("p",null,[i("strong",null,[t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[108]||(s[108]=[l("生产者端优化",-1)])]),_:1})])]),i("p",null,[s[111]||(s[111]=i("strong",null,"控制生产速度",-1)),s[112]||(s[112]=l("：例如",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[109]||(s[109]=[l("在生产者端设置",-1)])]),_:1}),i("strong",null,[t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[110]||(s[110]=[l("限流机制",-1)])]),_:1})]),s[113]||(s[113]=l("，避免消息生产速度过快",-1))]),i("p",null,[i("strong",null,[t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[114]||(s[114]=[l("Kafka集群优化",-1)])]),_:1})])]),s[195]||(s[195]=i("p",null,[i("strong",null,"调整分区数量"),l("：根据消息生产和消费速度，合理调整主题的分区数量。如果消息堆积是由于分区数过少导致，可增加分区数。例如，将一个原本只有2个分区的主题，根据业务量增加到10个分区，以"),i("strong",null,"提高并行处理能力"),l("。但分区数过多也会增加管理开销，需谨慎评估。")],-1)),s[196]||(s[196]=i("h4",{id:"redis库存扣减了-但是数据库的库存没有扣减、订单没有生成怎么办",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#redis库存扣减了-但是数据库的库存没有扣减、订单没有生成怎么办"},[i("span",null,[i("em",null,[i("strong",null,"Redis库存扣减了，但是数据库的库存没有扣减、订单没有生成怎么办？")])])])],-1)),i("p",null,[s[116]||(s[116]=l("一人一单和库存不超卖，是由 Redis 存储库存和订单信息，使用 Lua 完成用户下单资格判断 来保证的。 ",-1)),t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[115]||(s[115]=[l("秒杀的核心要求不受影响",-1)])]),_:1}),s[117]||(s[117]=l("。",-1))]),s[197]||(s[197]=i("p",null,"如果消息丢失了，其实只是MySQL中的库存信息不正确、以及用户的订单记录没有及时生成。即数据一致性的问题。",-1)),i("p",null,[s[120]||(s[120]=l("此时完全可以设计一个",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[118]||(s[118]=[l("兜底策略",-1)])]),_:1}),s[121]||(s[121]=l("。设置一个在秒杀结束后执行的",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[119]||(s[119]=[l("定时任务，去检查Redis的库存信息和MySQL的库存信息是否一致，检查订单是否都正常生成。",-1)])]),_:1}),s[122]||(s[122]=l("如果有异常情况，即可修复。",-1))]),i("blockquote",null,[i("p",null,[s[124]||(s[124]=i("strong",null,"其实就是一个对账的思想/策略",-1)),s[125]||(s[125]=l("，也就是说上面其实可以不用Set存储购买过优惠券的用户ID，而是像前面说过的用Hash，这样在最后定时任务可以去",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[123]||(s[123]=[l("查Redis中的订单数据和MySQL中的订单数据",-1)])]),_:1}),s[126]||(s[126]=l("，进行比对验证。如果一致就没问题，如果不一致，那么可能是丢消息了或者系统执行异常了。可能需要人工介入排查。",-1))])]),s[198]||(s[198]=i("h4",{id:"_4-顺序消费的实现",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_4-顺序消费的实现"},[i("span",null,[l("（4）"),i("em",null,[i("strong",null,"顺序消费的实现")])])])],-1)),s[199]||(s[199]=i("p",null,[i("strong",null,"消息顺序消费指的是，多个消息需要按照先后顺序依次消费")],-1)),s[200]||(s[200]=i("p",null,"多个消息 如果写入同一个 Topic 的不同 partition 分区，由于不同 partition 分区消息被消费的速度是不可预知的，所以此时无法保证消息被顺序消费，",-1)),i("p",null,[s[128]||(s[128]=l("因此，多个消息，需要",-1)),t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[127]||(s[127]=[l("写入同一个 Topic 的 同一个 partition 分区",-1)])]),_:1}),s[129]||(s[129]=l("，至少在单个分区内，消息是有序的，同时，需要保证每个 partition 分区由一个消费者消费，确保 单个分区内的消息按顺序处理。",-1))]),s[201]||(s[201]=k(`<h4 id="_5-使用kafka的代码参考" tabindex="-1"><a class="header-anchor" href="#_5-使用kafka的代码参考"><span>（5）<em><strong>使用Kafka的代码参考</strong></em></span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 引入 KafkaTemplate, 类似于 RedisTemplate</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> KafkaTemplate</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> kafkaTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Result</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> seckillVoucher</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Long</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> voucherId) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> userId </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> UserHolder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getUser</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 1.执行lua脚本,判断是否有资格下单</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> result </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> stringRedisTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">execute</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    SECKILL_SCRIPT,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    Collections</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">emptyList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(),</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    voucherId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(),</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    userId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(result </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Result</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">fail</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;库存不足&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(result </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Result</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">fail</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;重复下单&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 有购买资格</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> orderId </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redisIdWorker</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">nextId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;order&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">VoucherOrder</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> voucherOrder </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> VoucherOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">voucherOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(orderId);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 订单ID</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">voucherOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setUserId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(userId);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 用户ID</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">voucherOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setVoucherId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(voucherId);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 优惠券ID</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 生产Kafka消息</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> topic </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;指定的Topic&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ListenableFuture</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">SendResult</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Object</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> future </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> kafkaTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">send</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(topic, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">voucherOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 回调函数</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">future</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">addCallback</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ListenableFutureCallback</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">SendResult</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> onFailure</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Throwable</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> ex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">error</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;kafka sendMessage error, ex = {}, topic = {}, data = {}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, ex, topic, voucherOrder);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> onSuccess</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">SendResult</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">result</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">info</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;kafka sendMessage success topic = {}, data = {}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, topic, voucherOrder);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    });</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">info</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;kafka sendMessage end&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Result</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ok</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(orderId);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Slf4j</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> SeckillVoucherConsumer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">KafkaListener</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">topics</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;#{kafkaTopicName}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> processMessage</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ConsumerRecord</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">record</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Acknowledgment</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> ack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 获取消息内的数据</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">            VoucherOrder</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> order</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (VoucherOrder) </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">record</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 1. 生成订单... 操作数据库</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 2. 扣减库存... 操作数据库</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            ack</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">acknowledge</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 仅业务成功时提交</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Exception</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">error</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;消费异常: topic={}, offset={}, 原因={}&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                      record</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">topic</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">record</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">offset</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getMessage</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 不提交！等待重试或进入死信队列</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三、kafka技术细节" tabindex="-1"><a class="header-anchor" href="#三、kafka技术细节"><span>三、Kafka技术细节</span></a></h2><h3 id="_3-1-消息队列作用" tabindex="-1"><a class="header-anchor" href="#_3-1-消息队列作用"><span>3.1 消息队列作用</span></a></h3><p>MQ：MessageQueue，消息队列。 队列，是⼀种FIFO 先进先出的数据结构。消息则是跨进程传递的数据。</p><p>⼀个典型的MQ系统，会将消息消息由⽣产者发送到MQ进⾏排队，然后根据⼀定的顺序交由消息的消费者进⾏</p><p>处理。 QQ和微信就是典型的MQ。只不过他对接的使⽤对象是⼈，⽽Kafka需要对接的使⽤对象是应⽤程序。</p>`,8)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[130]||(s[130]=[l("MQ的作⽤主要有以下三个⽅⾯：",-1)])]),_:1}),s[202]||(s[202]=k('<ul><li>异步：能提⾼系统的响应速度、吞吐量。</li><li>解耦：减少服务之间的影响，便于拓展。</li><li>削峰：以稳定的系统资源应对突发的流量冲击。</li></ul><h3 id="_3-2-kafka核心概念" tabindex="-1"><a class="header-anchor" href="#_3-2-kafka核心概念"><span>3.2 kafka核心概念</span></a></h3><div class="hint-container info"><p class="hint-container-title">重要组件</p><p>Kafka 包含若干 Producer、若干Broker、若干 Consumer 以及一个 Zookeeper 集群。</p><ul><li>Zookeeper 是 Kafka 用来负责集群元数据管理、控制器选举等操作的。</li><li>Producer 是负责将消息发送到 Broker 的。</li><li>Broker 负责接受消息，将消息持久化到磁盘。</li><li>Consumer 是负责从 Broker 订阅并消费消息。</li></ul></div>',3)),r(" 这是一张图片，ocr 内容为： "),s[203]||(s[203]=k('<figure><img src="https://jiwang.cc.cd/PicGo/1771390788820-1639c971-bf54-421b-b845-69b6f6b371e2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_1-broker" tabindex="-1"><a class="header-anchor" href="#_1-broker"><span>（1）Broker</span></a></h4><ul><li>一个Kafka的集群通常由多个Broker组成，这样才能实现负载均衡、以及容错</li><li>Broker是**无状态（Sateless）**的，它们是通过ZooKeeper来维护集群状态</li><li>一个Kafka的Broker每秒可以处理数十万次读写，每个Broker都可以处理TB消息而不影响性能</li></ul><h4 id="_2-zookeeper" tabindex="-1"><a class="header-anchor" href="#_2-zookeeper"><span>（2）Zookeeper</span></a></h4><ul><li>ZK用来管理和协调 Broker，并且存储了Kafka的元数据（例如：有多少topic、partition、consumer、producer）</li><li>ZK服务主要用于通知生产者和消费者Kafka集群中有新的Broker加入、或者Kafka集群中出现故障的Broker。</li></ul><h4 id="_3-topic" tabindex="-1"><a class="header-anchor" href="#_3-topic"><span>（3）Topic</span></a></h4>',6)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[131]||(s[131]=[l("Kafka中Topic是一个逻辑概念",-1)])]),_:1}),s[204]||(s[204]=i("ul",null,[i("li",null,[l("所谓发布订阅机制 "),i("ul",null,[i("li",null,"生产者发布的消息是需要指定一个Topic的，含义即这个消息属于这个“主题”Topic，也可以把“主题”理解为“类别”，生产者就会把消息发送到所指定的Topic。"),i("li",null,"通常一个Topic中只会专门存储某一类的（消息）信息，比如 Topic（A）专门存储用户观看直播时长信息、Topic（B）专门存储直播PK开始信息。并且在一个Topic中的消息是有固定结构的。"),i("li",null,"消费者是从它所指定订阅的 “主题”Topic 中去拉取的。")])]),i("li",null,"一个主题Topic被分成多个Partition分区")],-1)),s[205]||(s[205]=i("h4",{id:"_4-partition",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_4-partition"},[i("span",null,"（4）Partition")])],-1)),r(" 这是一张图片，ocr 内容为： "),s[206]||(s[206]=i("figure",null,[i("img",{src:"https://jiwang.cc.cd/PicGo/1771390788866-5c6bfb41-4389-4065-b414-5e9a91480a4e.png",alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1)),s[207]||(s[207]=i("p",null,"一个主题Topic被分成多个Partition分区（Topic是逻辑概念，即无实体的）",-1)),s[208]||(s[208]=i("ul",null,[i("li",null,"Partition分区 是最小的存储单元，掌握着一个Topic的部分数据。"),i("li",null,"每个 Partition 分区都是一个单独的 log 文件，每条记录都以追加的形式写入。"),i("li",null,"一个 Topic 的所有 Partition分区 是分布在多个不同的Broker中的，所有 Partition 分区的数据的并集就是所有数据，提高容错率、提高消息的消费能力。"),i("li",null,"一个 Partition 会生成多个副本Replica，并且把它们分散存储在不同的 Broker 中。在Kafka中，一般都会设计副本Replica的个数 > 1")],-1)),s[209]||(s[209]=i("h4",{id:"_5-offset",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_5-offset"},[i("span",null,"（5）Offset")])],-1)),t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[132]||(s[132]=[l("Offset 的定义",-1)])]),_:1}),i("p",null,[s[134]||(s[134]=l("Offset 是 Kafka 在分区内为每条消息分配的递增编号，",-1)),t(n,{style:{"background-color":"rgba(255,246,122,0.8)"}},{default:a(()=>[...s[133]||(s[133]=[l("本质上是消息在日志文件中的物理位置",-1)])]),_:1}),s[135]||(s[135]=l("。它是单调递增且不可重用的，即使旧消息因过期被删除，新的消息仍然使用更大的 Offset。这种设计保证了消费者可以基于 Offset 精确地控制消费进度，并实现 at-least-once 语义。",-1))]),t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[136]||(s[136]=[l("Offset 的作用",-1)])]),_:1}),s[210]||(s[210]=i("ul",null,[i("li",null,[l("定位消息。"),i("strong",null,"通过指定 offset，消费者可以准确地找到分区中的某条消息，或者从某个位置开始消费消息"),l("。")]),i("li",null,[i("strong",null,"记录消费进度"),l("。消费者在消费完一条消息后，需要提交 offset 来告诉 Kafka broker 自己消费到哪里了。这样，如果消费者发生故障或重启，它可以根据保存的 offset 来恢复消费状态。")])],-1)),t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[137]||(s[137]=[l("Offset 的存储",-1)])]),_:1}),s[211]||(s[211]=i("ul",null,[i("li",null,"老版本默认Kafka将Offset存储在Zookeeper中"),i("li",null,"Kafka 0.9.0 版本后，offset 的实际存储位置都是在 Kafka 的一个内置主题中：consumer_offsets。这个主题有 50 个分区（可配置），每个分区存储一部分消费组（Consumer Group）的 offset 信息。Kafka broker 会根据消费组 ID 和主题名来计算出一个哈希值，并将其映射到 consumer_offsets 主题的某个分区上。")],-1)),t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[138]||(s[138]=[l("Offset 的提交与重置",-1)])]),_:1}),t(n,{style:{color:"#DF2A3F"}},{default:a(()=>[...s[139]||(s[139]=[l("提交 offset",-1)])]),_:1}),s[212]||(s[212]=k('<p>消费者在消费 Kafka 消息时，需要维护</p><ul><li>当前消费的 offset 值，表示消费者正在消费的消息的位置，</li><li>已提交的 offset 值，表示消费者已经跟Kafka确认了已消费过的消息的位置。</li></ul><p>消费者在消费完一条消息后，需要提交 offset 来更新已提交的 offset 值。</p><p>提交 offset 的方式有两种：自动提交和手动提交。</p><ul><li>自动提交：Kafka 提供了一个配置参数 enable.auto.commit，默认为 true，表示开启自动提交功能。<strong>自动提交功能会在后台定期</strong>（由 <a href="http://auto.commit.interval.ms" target="_blank" rel="noopener noreferrer">auto.commit.interval.ms</a> 参数控制）<strong>将当前消费的 offset 值提交给 Kafka broker。</strong></li><li>手动提交：如果 enable.auto.commit 设置为 false，则表示关闭自动提交功能，此时**消费者需要手动调用 commitSync 或 commitAsync 方法来提交 offset。**手动提交功能可以让消费者更灵活地控制何时以及如何提交 offset。</li></ul>',5)),i("div",u,[s[153]||(s[153]=i("p",{class:"hint-container-title"},"注意",-1)),i("p",null,[s[143]||(s[143]=l("需要注意的是，",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[140]||(s[140]=[l("无论是自动提交还是手动提交，都不保证提交成功",-1)])]),_:1}),s[144]||(s[144]=l("。因为 Kafka broker 可能发生故障或网络延迟，导致",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[141]||(s[141]=[l("提交失败或延迟",-1)])]),_:1}),s[145]||(s[145]=l("。因此，",-1)),t(n,{style:{"background-color":"rgba(255,246,122,0.8)"}},{default:a(()=>[...s[142]||(s[142]=[l("消费者需要处理提交失败或延迟的情况",-1)])]),_:1}),s[146]||(s[146]=l("。",-1))]),i("ul",null,[s[152]||(s[152]=i("li",null,"提交失败：消费者可以选择重试或放弃。重试的话，可能会导致多次提交同一个 offset 值，但是不会影响正确性，因为 Kafka broker 会忽略重复的 offset 值。放弃的话，可能会导致下次启动时重新消费已经消费过的消息。",-1)),i("li",null,[s[149]||(s[149]=l("提交延迟：消费者可以选择等待或继续。等待的话，可能会导致",-1)),t(n,{style:{"background-color":"rgba(255,246,122,0.8)"}},{default:a(()=>[...s[147]||(s[147]=[l("消费速度变慢",-1)])]),_:1}),s[150]||(s[150]=l("，或者",-1)),t(n,{style:{"background-color":"rgba(255,246,122,0.8)"}},{default:a(()=>[...s[148]||(s[148]=[l("超过会话时间",-1)])]),_:1}),s[151]||(s[151]=l("而被认为已经死亡。继续的话，可能会导致下次启动时漏掉一些没有提交成功的消息。",-1))])])]),t(n,{style:{color:"#DF2A3F"}},{default:a(()=>[...s[154]||(s[154]=[l("重置 offset",-1)])]),_:1}),s[213]||(s[213]=i("ul",null,[i("li",null,"手动重置：可以让消费者精确地控制从哪个位置开始消费。"),i("li",null,"自动重置：对应三个选项，earliest, latest 和 none。earliest 表示从最早的可用消息开始消费；latest 表示从最新的可用消息开始消费；none 表示如果没有可用的 offset，则抛出异常。")],-1)),s[214]||(s[214]=i("h4",{id:"_6-消费者组",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_6-消费者组"},[i("span",null,"（6）消费者组")])],-1)),s[215]||(s[215]=i("p",null,"多个消费者，只要指定了相同的 group_id ，即属于同一个消费者组",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[155]||(s[155]=[l("同一个消费者组内的消费者可以共同消费一个Topic中的数据",-1)])]),_:1}),s[216]||(s[216]=l("，",-1)),s[217]||(s[217]=i("p",null,"但是一个Topic中是有很多Partition的，消费者是怎么分配 Partition 的呢？",-1)),i("ul",null,[s[162]||(s[162]=i("li",null,[l("例如有一个Topic，含有一个Partition，有一个消费者组（有消费者A，B），此时消费者A和消费者B中只有一个消费者可以消费到消息，另外一个消费者将不会消费到消息。"),i("strong",null,"这说明当一个消费者组内的消费者数量 > 某 Topic 的 Partition 数量时，多余的消费者是会空闲的"),l("。")],-1)),i("li",null,[s[157]||(s[157]=l("例如有一个Topic，含有两个Partition，有一个消费者组（有消费者A，B），此时消费者A和消费者B会分别单独只消费某一个Partition，A和B不会交叉消费不同Partition。",-1)),s[158]||(s[158]=i("strong",null,"这说明当一个消费者组内的消费者数量 == 某 Topic 的 Partition 数量时，每个消费者对应一个Partition。",-1)),t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[156]||(s[156]=[l("（单播）",-1)])]),_:1})]),i("li",null,[s[161]||(s[161]=l("例如有一个Topic，含有三个Partition，有一个消费者组（有消费者A，B），此时消费者A和消费者B会有一个消费者消费多个分区。",-1)),i("strong",null,[s[160]||(s[160]=l("这说明当一个消费者组内的消费者数量 < 某Topic的Partition数量时，部分消费者会消费多个Partition的消息。****",-1)),t(n,{style:{"background-color":"#81DFE4"}},{default:a(()=>[...s[159]||(s[159]=[l("(多播)",-1)])]),_:1})])])]),t(n,{style:{"background-color":"rgba(255,246,122,0.8)"}},{default:a(()=>[...s[163]||(s[163]=[l("不同消费者组可以共同消费同一个Topic中的数据。",-1)])]),_:1}),i("ul",null,[i("li",null,[s[165]||(s[165]=l("假设有两个消费者组A和B，都订阅了同一个Topic，这时候Topic的某一条消息，消费者组A和消费者组B都可以拉取到。",-1)),t(n,{style:{color:"rgb(216,57,49)"}},{default:a(()=>[...s[164]||(s[164]=[l("即消费者组A会消费一次，消费者组B也会消费一次。",-1)])]),_:1}),s[166]||(s[166]=l("消费组内具体的消费逻辑同上单个消费者组组内消费的逻辑。",-1))])]),i("div",y,[s[172]||(s[172]=i("p",{class:"hint-container-title"},"注意",-1)),i("p",null,[s[169]||(s[169]=l("Kafka 采用",-1)),t(n,{style:{color:"#DF2A3F"}},{default:a(()=>[...s[167]||(s[167]=[l("拉模式",-1)])]),_:1}),s[170]||(s[170]=l("消费消息，即消费者主动通过 poll() 向 Broker 请求数据，而不是由 Broker 主动推送。这种设计的好处是消费者可以",-1)),t(n,{style:{color:"#DF2A3F"}},{default:a(()=>[...s[168]||(s[168]=[l("根据自身处理能力控制拉取频率和批量大小，从而避免被高并发消息压垮",-1)])]),_:1}),s[171]||(s[171]=l("，同时提高批量处理效率，是 Kafka 高吞吐架构的重要基础。",-1))])])])}const b=p(h,[["render",B]]),E=JSON.parse(`{"path":"/projects/dianping/04.%20%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80.html","title":"04. 优惠券秒杀","lang":"en-US","frontmatter":{"title":"04. 优惠券秒杀","article":false,"category":["项目","《优享生活圈》"],"tag":["防超卖","一人一单","Kafka"],"date":"2026-02-15T00:00:00.000Z","description":"一、秒杀防超卖和一人一单 秒杀防超卖和一人一单：使用 Redis 存储库存和订单信息，Lua 判断用户下单资格，保证库存不超卖和一人一单； 1.1 问题解决 背景 平台上商家可以发布一些折扣力度很大的优惠券，这种优惠券是某个时间点限量供应的，所以在这个时间点会有比较大的流量进入，也就是一个秒杀场景，必须要保证的是在高并发的情况下，防止库存超卖，以及这种...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"04. 优惠券秒杀\\",\\"description\\":\\"一、秒杀防超卖和一人一单 秒杀防超卖和一人一单：使用 Redis 存储库存和订单信息，Lua 判断用户下单资格，保证库存不超卖和一人一单； 1.1 问题解决 背景 平台上商家可以发布一些折扣力度很大的优惠券，这种优惠券是某个时间点限量供应的，所以在这个时间点会有比较大的流量进入，也就是一个秒杀场景，必须要保证的是在高并发的情况下，防止库存超卖，以及这种...\\"}"],["meta",{"property":"og:url","content":"https://jiwang.online/projects/dianping/04.%20%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80.html"}],["meta",{"property":"og:site_name","content":"jiwang's blog"}],["meta",{"property":"og:title","content":"04. 优惠券秒杀"}],["meta",{"property":"og:description","content":"一、秒杀防超卖和一人一单 秒杀防超卖和一人一单：使用 Redis 存储库存和订单信息，Lua 判断用户下单资格，保证库存不超卖和一人一单； 1.1 问题解决 背景 平台上商家可以发布一些折扣力度很大的优惠券，这种优惠券是某个时间点限量供应的，所以在这个时间点会有比较大的流量进入，也就是一个秒杀场景，必须要保证的是在高并发的情况下，防止库存超卖，以及这种..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:image","content":"https://jiwang.cc.cd/PicGo/1771390788820-1639c971-bf54-421b-b845-69b6f6b371e2.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2026-02-18T14:36:35.000Z"}],["meta",{"property":"article:tag","content":"Kafka"}],["meta",{"property":"article:tag","content":"一人一单"}],["meta",{"property":"article:tag","content":"防超卖"}],["meta",{"property":"article:published_time","content":"2026-02-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-18T14:36:35.000Z"}]]},"git":{"createdTime":1771425395000,"updatedTime":1771425395000,"contributors":[{"name":"dongjiwang","username":"dongjiwang","email":"1790921341@qq.com","commits":1,"url":"https://github.com/dongjiwang"}]},"readingTime":{"minutes":22.43,"words":6729},"filePathRelative":"projects/dianping/04. 优惠券秒杀.md","excerpt":"<h2>一、秒杀防超卖和一人一单</h2>\\n<ul>\\n<li><strong>秒杀防超卖和一人一单</strong>：使用 Redis 存储库存和订单信息，Lua 判断用户下单资格，保证库存不超卖和一人一单；</li>\\n</ul>\\n<h3>1.1 问题解决</h3>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">背景</p>\\n<p>平台上商家可以发布一些折扣力度很大的优惠券，这种优惠券是某个时间点限量供应的，所以在这个时间点会有比较大的流量进入，也就是一个秒杀场景，必须要保证的是在高并发的情况下，防止库存超卖，以及这种优惠券是限制每位用户只能购买一次。即防库存超卖和一人一单。</p>\\n<p>要达到目的，只需要做好校验，校验用户是否有资格下单，如果库存不足或者用户已经下过单，则此时可认为用户是没有资格下单，拒绝请求。反之用户有资格下单则进行后续流程。</p>\\n</div>","autoDesc":true}`);export{b as comp,E as data};
