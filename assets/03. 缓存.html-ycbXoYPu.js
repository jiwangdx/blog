import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,a as l,e as n,b as s,w as r,d as e,r as u,o as g}from"./app-D9h6flBx.js";const p={},y={class:"hint-container warning"},f={style:{"text-align":"center"}},b={style:{"text-align":"center"}},a={style:{"text-align":"center"}},R={style:{"text-align":"center"}},m={style:{"text-align":"center"}},x={style:{"text-align":"center"}},F={style:{"text-align":"center"}},k={style:{"text-align":"center"}},C={style:{"text-align":"center"}},T={style:{"text-align":"center"}},L={style:{"text-align":"center"}},B={style:{"text-align":"center"}},E={style:{"text-align":"center"}},K={style:{"text-align":"center"}},D={style:{"text-align":"center"}},S={style:{"text-align":"center"}},M={style:{"text-align":"center"}},q={style:{"text-align":"center"}},v={style:{"text-align":"center"}},w={style:{"text-align":"center"}},A={style:{"text-align":"center"}},X={style:{"text-align":"center"}},j={style:{"text-align":"center"}},U={style:{"text-align":"center"}};function Q(H,t){const o=u("font");return g(),d("div",null,[l("ol",null,[l("li",null,[t[1]||(t[1]=l("strong",null,"缓存优化",-1)),t[2]||(t[2]=n("：使用",-1)),s(o,{style:{color:"rgb(216,57,49)"}},{default:r(()=>[...t[0]||(t[0]=[n("逻辑过期方案",-1)])]),_:1}),t[3]||(t[3]=n("防止 Redis 热点 Key 的缓存击穿问题；使用缓存空值方案解决 Redis Key 的缓存穿透问题；",-1))]),t[4]||(t[4]=l("li",null,[l("strong",null,"数据一致性"),n("：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性；")],-1)),t[5]||(t[5]=l("li",null,[l("strong",null,"多级缓存"),n("：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redis 压力；")],-1))]),t[112]||(t[112]=l("h2",{id:"一、缓存击穿",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#一、缓存击穿"},[l("span",null,"一、缓存击穿")])],-1)),t[113]||(t[113]=l("div",{class:"hint-container info"},[l("p",{class:"hint-container-title"},"背景"),l("p",null,"对于平台的准点开放、限时的一些活动信息 或者 热搜榜单，它们是一个热点数据，在活动上线之前，我们需要提前预热：将其存入 Redis 中进行缓存，目的是提高系统的响应速度，降低数据库的访问压力。"),l("p",null,"当把高并发场景的热点数据存入 Redis 缓存，那么我们需要考虑的问题是：缓存击穿的问题。如果缓存的热点数据失效过期的瞬间，有大量的请求访问，那么大量请求将到达数据库，导致数据库瞬时压力过大甚至可能崩溃。")],-1)),t[114]||(t[114]=l("p",null,"解决缓存击穿的问题，有两种解决方案：一是使用互斥锁。二是使用逻辑过期。",-1)),l("p",null,[l("strong",null,[s(o,{style:{color:"rgb(222,120,2)","background-color":"#EFF0F0"}},{default:r(()=>[...t[6]||(t[6]=[n("互斥锁",-1)])]),_:1})]),s(o,{style:{"background-color":"#EFF0F0"}})]),t[115]||(t[115]=l("p",null,[n("当缓存失效时，有大量请求都会去访问数据库，希望获取数据且重新建立缓存再返回给用户数据。"),l("strong",null,"但其实只需要一个请求对应的线程去访问数据库，重新建立起缓存即可"),n("。")],-1)),t[116]||(t[116]=l("p",null,"在请求到达缓存后，若缓存不存在，尝试获取互斥锁，大量的请求中，只有一个线程获取锁成功，由这个线程去查询数据库，重新建立缓存，而其他的请求线程获取锁失败，都休眠一小段时间后，不断重试获取缓存数据。",-1)),t[117]||(t[117]=l("blockquote",null,[l("p",null,[l("strong",null,"互斥锁的方案，最终只有一个线程去访问数据库，降低了数据库的访问压力，解决了缓存击穿的问题，但是其他的线程需要等待，性能受到影响，对于外界可能表现出一些不可用或者延迟的现象，但是保证了强一致性。")])],-1)),l("p",null,[l("strong",null,[s(o,{style:{color:"rgb(222,120,2)","background-color":"#EFF0F0"}},{default:r(()=>[...t[7]||(t[7]=[n("逻辑过期",-1)])]),_:1})])]),t[118]||(t[118]=e("<p>针对热点数据我们<strong>不设置TTL</strong>，也就是说Redis Key永不失效，而是在Redis的Value数据中新增一个属性存储过期时间字段。</p><p>在获取key时需要检查过期时间字段，判断是否过期，如果发现过期，则尝试获取互斥锁，大量的请求中，只有一个线程获取锁成功，由这个线程去开启一个独立线程去查询数据库重建缓存，而其他线程就直接返回Redis中的旧数据。</p><blockquote><p><strong>这个逻辑过期的方案，最终也是只有一个线程去访问数据库，降低了数据库的访问压力，解决了缓存击穿的问题，并且线程无需等待，性能比较好，保证了服务的可用性，但是部分请求返回了Redis的旧数据，没有保证一致性。</strong></p></blockquote><p>这两个方案的对比，其实就是 **可用性和一致性的抉择 (CAP定理) **：</p><ul><li>互斥锁保证了一致性，牺牲了可用性；</li><li>逻辑过期保证了可用性，而牺牲了一致性</li></ul><p><strong>针对这个热搜榜单，它其实是一种社交媒体类型的数据，对于一致性的要求不是很高，因此最终为了保证服务的可用性，选择使用逻辑过期的方案来解决缓存击穿问题。</strong></p>",6)),l("p",null,[t[9]||(t[9]=n("在测试阶段，(手动修改数据库中的数据，使得Redis和MySQL数据不一致)，然后等到Redis中的数据逻辑上过期后，使用 Jmeter 进行压力测试，在5s内5000个线程并发请求，QPS是1000，",-1)),s(o,{style:{color:"rgb(216,57,49)"}},{default:r(()=>[...t[8]||(t[8]=[n("查看日志可以发现只有一次查询数据库重建缓存的过程",-1)])]),_:1}),t[10]||(t[10]=n("，",-1)),t[11]||(t[11]=l("strong",null,"证明在高并发的场景下，没有让所有的请求打到数据库，成功使用逻辑过期方案解决缓存击穿问题",-1)),t[12]||(t[12]=n("。缺点就是在缓存尚未重建完毕时，前面一小部分的请求(大概200ms是缓存重建的耗时)获取到的是旧的Redis数据，后面所有的请求获取到的是正确的数据。",-1))]),t[119]||(t[119]=e('<div class="hint-container warning"><p class="hint-container-title">注意</p><p>金融类的业务场景，是要求强一致性的，会使用互斥锁方案。</p></div><h2 id="二、数据一致性" tabindex="-1"><a class="header-anchor" href="#二、数据一致性"><span>二、数据一致性</span></a></h2><h3 id="_2-1-问题解决" tabindex="-1"><a class="header-anchor" href="#_2-1-问题解决"><span>2.1. 问题解决</span></a></h3><div class="hint-container info"><p class="hint-container-title">背景</p><p>把数据存入Redis缓存，MySQL中的数据是会更新的，需要设法保证Redis和MySQL的数据一致性。</p></div>',4)),l("p",null,[t[14]||(t[14]=n("在",-1)),s(o,{style:{color:"rgb(222,120,2)"}},{default:r(()=>[...t[13]||(t[13]=[n("更新数据库后，再同步删除缓存",-1)])]),_:1}),t[15]||(t[15]=n("，若删除缓存失败，则发送一个消息到Kafka中，消息中携带上要删除的key的信息，同时需要启动Kafka消费者，消费者接收到消息后执行缓存删除逻辑。如果删除缓存失败，消息队列的重试机制就可以发挥作用，",-1)),t[16]||(t[16]=l("strong",null,"梯度重试",-1)),t[17]||(t[17]=n("的去删除缓存，",-1)),t[18]||(t[18]=l("strong",null,"尽量保证",-1)),t[19]||(t[19]=n("数据的",-1)),t[20]||(t[20]=l("strong",null,"最终一致性",-1)),t[21]||(t[21]=n("。",-1))]),l("blockquote",null,[t[27]||(t[27]=l("p",null,"梯度重试（Exponential Backoff）是一种用于处理失败的重试机制，它会根据重试的次数逐渐增加重试的间隔时间，避免在短时间内频繁地重复操作，从而减少系统的负载和资源消耗。",-1)),l("ul",null,[l("li",null,[t[26]||(t[26]=n("删除缓存还是更新缓存？ ",-1)),l("ul",null,[t[25]||(t[25]=l("li",null,"更新缓存：每次更新数据库都更新缓存，无效写操作较多",-1)),l("li",null,[t[23]||(t[23]=n("删除缓存：",-1)),s(o,{style:{color:"rgb(216,57,49)"}},{default:r(()=>[...t[22]||(t[22]=[n("更新数据库时让缓存失效",-1)])]),_:1}),t[24]||(t[24]=n("，查询时再更新缓存",-1))])])])])]),l("div",y,[t[31]||(t[31]=l("p",{class:"hint-container-title"},"注意",-1)),l("p",null,[t[29]||(t[29]=n("当然保证数据一致性还有很多方案，例如binlog 监听同步，",-1)),s(o,{style:{color:"rgb(216,57,49)"}},{default:r(()=>[...t[28]||(t[28]=[n("延迟双删，Canal + 异步更新缓存",-1)])]),_:1}),t[30]||(t[30]=n("。当然上述方法都不能保证MySQL数据和Redis缓存的数据强一致性，只是保证最终一致性。",-1))]),t[32]||(t[32]=l("p",null,[l("strong",null,'无论选择哪种方案都需要为缓存设置TTL，作为兜底策略。"设置过期时间"就像是给缓存加了"自动清理保险"，即使我们主动删除失败，系统也能在一定时间后自我修复，避免永久性的数据不一致。')],-1))]),t[120]||(t[120]=e('<h3 id="_2-2-衍生思考" tabindex="-1"><a class="header-anchor" href="#_2-2-衍生思考"><span>2.2 衍生思考</span></a></h3><h4 id="_1-使用消息队列重试-如果一直失败怎么办" tabindex="-1"><a class="header-anchor" href="#_1-使用消息队列重试-如果一直失败怎么办"><span>（1）使用消息队列重试，如果一直失败怎么办？</span></a></h4><p><strong>记录失败次数</strong>，程序里检测达到最大重试次数后，<strong>触发告警，人工介入排查原因</strong></p><h4 id="_2-为什么是先更新mysql-后删除redis缓存" tabindex="-1"><a class="header-anchor" href="#_2-为什么是先更新mysql-后删除redis缓存"><span>（2）为什么是先更新MySQL，后删除Redis缓存？</span></a></h4>',4)),l("p",null,[t[34]||(t[34]=n("选择“先更新数据库，再删除缓存”，核心考虑是",-1)),s(o,{style:{color:"rgb(216,57,49)"}},{default:r(()=>[...t[33]||(t[33]=[n("尽量缩短不一致窗口",-1)])]),_:1}),t[35]||(t[35]=n("。",-1))]),s(o,{style:{"background-color":"#CEF5F7"}},{default:r(()=>[...t[36]||(t[36]=[n("更新DB --> 删缓存",-1)])]),_:1}),t[121]||(t[121]=e("<p><code>从不一致窗口的角度来看</code>，这里数据不一致的时间，就是缓存删除的时间。</p><p><code>从数据不一致的原因来看</code>，分析如下，初始状态为<code>缓存：null，DB：X1</code></p><pre><code>1. 读请求：缓存未命中，读取数据库的值为`X1`\n2. 写请求：请求更新数据库的值为`X2`，并且执行删除缓存的操作\n3. 读请求：将`X1`写回缓存\n</code></pre><p>这样最终状态是<code>DB：X2``缓存：X1</code> 不一致</p><blockquote><p><strong>但上述情况出现的概率很小</strong>：因为 <code>更新MySQL的耗时 &gt;&gt; 读请求写入Redis缓存的耗时</code>，正常流程下就是读缓存未命中--&gt;读数据库拿到值写入redis--&gt;写请求完成mysql更新并且删除缓存，即最终状态为<code>DB：X2``缓存：null</code> 。</p></blockquote><p><code>考虑更新失败的情况：万一数据库出了啥问题更新失败</code>，Redis没删除，数据库和缓存还是一致的，<code>万一缓存删除失败</code>，可以消息队列重试或者设置过期时间兜底，这就是可修复的不一致。</p>",6)),s(o,{style:{"background-color":"#CEF5F7"}},{default:r(()=>[...t[37]||(t[37]=[n("删缓存 --> 更新DB",-1)])]),_:1}),l("p",null,[t[39]||(t[39]=l("code",null,"从不一致窗口的角度来看",-1)),t[40]||(t[40]=n("，这里数据不一致的时间，看起来是缩短了。确实，如果没有高并发，看起来可以忽略不计，但高并发会让",-1)),s(o,{style:{color:"rgb(216,57,49)"}},{default:r(()=>[...t[38]||(t[38]=[n("不一致窗口",-1)])]),_:1}),t[41]||(t[41]=n("变得很大。",-1))]),t[122]||(t[122]=l("p",null,[l("code",null,"**从数据不一致的原因来看**"),l("strong",null,"，分析如下，初始状态为"),l("code",null,"**缓存：null，DB：X1**")],-1)),t[123]||(t[123]=l("pre",null,[l("code",null,"1. 写请求：删除缓存\n2. 读请求：缓存未命中、读取数据库的值，更新缓存值为`X1`\n3. 写请求：更新数据库的值为`X2`\n")],-1)),l("p",null,[t[43]||(t[43]=n("这时不一致窗口就",-1)),s(o,{style:{color:"rgb(216,57,49)"}},{default:r(()=>[...t[42]||(t[42]=[n("退化",-1)])]),_:1}),t[44]||(t[44]=n("为 ",-1)),t[45]||(t[45]=l("code",null,"本次DB更新的时间+下次更新操作来临时删除缓存的时间",-1)),t[46]||(t[46]=n("。",-1))]),t[124]||(t[124]=l("blockquote",null,[l("p",null,[n("最致命的是上述情况发生概率很大，因为"),l("code",null,"更新MySQL的耗时 >> 删除Redis缓存的耗时"),n('，所以很有可能会有并发读请求在"删除缓存"和"更新数据库" 之间执行，导致数据不一致。')])],-1)),t[125]||(t[125]=l("p",null,[l("code",null,"考虑DB更新失败的情况："),n("缓存已经不在了，但是数据库没更新，就会导致超卖。")],-1)),l("table",null,[l("thead",null,[l("tr",null,[l("th",f,[l("strong",null,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[47]||(t[47]=[n("顺序",-1)])]),_:1})])]),l("th",b,[l("strong",null,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[48]||(t[48]=[n("不一致窗口",-1)])]),_:1})])]),l("th",a,[l("strong",null,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[49]||(t[49]=[n("风险级别",-1)])]),_:1})])])])]),l("tbody",null,[l("tr",null,[l("td",R,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[50]||(t[50]=[n("先更新DB，再删缓存",-1)])]),_:1})]),l("td",m,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[51]||(t[51]=[n("只有“删除失败”才不一致",-1)])]),_:1})]),l("td",x,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[52]||(t[52]=[n("低",-1)])]),_:1})])]),l("tr",null,[l("td",F,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[53]||(t[53]=[n("先删缓存，再更新DB",-1)])]),_:1})]),l("td",k,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[54]||(t[54]=[n("更新期间一定存在风险窗口",-1)])]),_:1})]),l("td",C,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[55]||(t[55]=[n("高",-1)])]),_:1})])])])]),t[126]||(t[126]=e(`<h4 id="_3-什么是延迟双删" tabindex="-1"><a class="header-anchor" href="#_3-什么是延迟双删"><span>（3）什么是延迟双删</span></a></h4><pre><code>1. 先删除缓存
2. 更新数据库
3. 延迟一定时间后，删除缓存
</code></pre><h2 id="三、多级缓存" tabindex="-1"><a class="header-anchor" href="#三、多级缓存"><span>三、多级缓存</span></a></h2><h3 id="_3-1-问题解决" tabindex="-1"><a class="header-anchor" href="#_3-1-问题解决"><span>3.1 问题解决</span></a></h3><div class="hint-container info"><p class="hint-container-title">背景</p><p>对于一些存储在Redis中的过热的key，例如秒杀优惠券的详情页，它本身是<strong>更新频率极低的，访问频率很高</strong>的数据。而Redis单实例性能有上限，单个Redis的压力过大，Redis可能成为系统瓶颈。</p></div>`,5)),l("p",null,[t[57]||(t[57]=n("考虑使用**",-1)),s(o,{style:{"background-color":"#CEF5F7"}},{default:r(()=>[...t[56]||(t[56]=[n("Caffeine本地缓存+Redis缓存",-1)])]),_:1}),t[58]||(t[58]=l("strong",null,"，搭建二级缓存，本地缓存将",-1)),t[59]||(t[59]=n("热 Key 的访问压力分散到各个应用实例的内存中，显著降低Redis的访问压力。**",-1))]),t[127]||(t[127]=l("p",null,"搭建二级缓存架构后，用户的请求流程将会是",-1)),l("ul",null,[t[63]||(t[63]=l("li",null,"先从本地缓存中获取数据，如果本地缓存有数据则返回数据",-1)),l("li",null,[t[61]||(t[61]=n("否则从Redis缓存中获取数据。",-1)),s(o,{style:{color:"rgb(222,120,2)"}},{default:r(()=>[...t[60]||(t[60]=[n("如果Redis缓存中有数据则更新本地缓存",-1)])]),_:1}),t[62]||(t[62]=n("，然后将数据返回客户端",-1))]),t[64]||(t[64]=l("li",null,"如果Redis缓存没有数据则去数据库查询数据，然后更新Redis缓存，接着再更新本地缓存，最后将数据返回给客户端",-1))]),l("p",null,[t[69]||(t[69]=n("当然使用本地缓存，有一个",-1)),s(o,{style:{color:"#DF2A3F"}},{default:r(()=>[...t[65]||(t[65]=[n("问题",-1)])]),_:1}),t[70]||(t[70]=n("是，",-1)),s(o,{style:{color:"rgb(222,120,2)"}},{default:r(()=>[...t[66]||(t[66]=[n("当后端服务",-1)])]),_:1}),l("strong",null,[s(o,{style:{color:"rgb(222,120,2)"}},{default:r(()=>[...t[67]||(t[67]=[n("集群部署",-1)])]),_:1})]),s(o,{style:{color:"rgb(222,120,2)"}},{default:r(()=>[...t[68]||(t[68]=[n("时",-1)])]),_:1}),t[71]||(t[71]=n("，如果数据库的数据有更新的情况，本地缓存的数据和数据库的数据会出现",-1)),t[72]||(t[72]=l("strong",null,"数据不一致窗口",-1)),t[73]||(t[73]=n("，如果要更新/删除本地缓存的数据，因为是集群部署，就要把所有节点的本地缓存的数据都进行更新/删除，此时这个实现稍微有些复杂，例如发送广播消息，所有实例节点监听广播消息，然后在本地缓存更新/删除。",-1))]),l("p",null,[t[75]||(t[75]=n("可以使用一种更简单的方法，就是我们可以**",-1)),s(o,{style:{color:"rgb(222,120,2)"}},{default:r(()=>[...t[74]||(t[74]=[n("给本地缓存设置较短时间的TTL",-1)])]),_:1}),t[76]||(t[76]=n("**，这样我们可以不用去管本地缓存的数据更新，而是仅依靠TTL，去不断刷新本地缓存的数据。",-1))]),t[128]||(t[128]=e('<h3 id="_3-2-衍生思考" tabindex="-1"><a class="header-anchor" href="#_3-2-衍生思考"><span>3.2 衍生思考</span></a></h3><h4 id="_1-redis单实例压力过大-为什么不搭建redis集群" tabindex="-1"><a class="header-anchor" href="#_1-redis单实例压力过大-为什么不搭建redis集群"><span>（1）Redis单实例压力过大，为什么不搭建Redis集群</span></a></h4><p>第一考虑成本问题，第二<code>即使搭建了Redis集群，热Key存在于某个Redis实例上</code>，依然会使得单台Redis实例压力过大，除非对该热Key进行分片，分散到不同的Redis实例上，这样实现复杂度又增加了。所以可以选择本地缓存方案，简单。</p><h4 id="_2-分布式缓存" tabindex="-1"><a class="header-anchor" href="#_2-分布式缓存"><span>（2）分布式缓存</span></a></h4>',4)),l("p",null,[t[79]||(t[79]=l("strong",null,"本地缓存",-1)),t[80]||(t[80]=n("：是单台应用服务器维度的缓存，会占用服务器本身存储空间。假设一个分布式系统有5台应用服务器，那么这5台服务器中的缓存内容是**",-1)),s(o,{style:{"background-color":"#CEF5F7"}},{default:r(()=>[...t[77]||(t[77]=[n("独立且相同",-1)])]),_:1}),t[81]||(t[81]=n("**的，彼此不相互影响。",-1)),s(o,{style:{color:"#DF2A3F"}},{default:r(()=>[...t[78]||(t[78]=[n("本地缓存更多的是用来频繁地读，而非写，数据会随着应用程序的重启而丢失。",-1)])]),_:1})]),t[129]||(t[129]=l("p",null,"优点：本地缓存不需要远程网络请求去操作内存空间，没有额外的性能消耗，所以读取速度快。",-1)),l("p",null,[t[83]||(t[83]=n("缺点：不能进行大数据量存储；",-1)),s(o,{style:{color:"rgb(222,120,2)"}},{default:r(()=>[...t[82]||(t[82]=[n("应用程序集群部署时",-1)])]),_:1}),t[84]||(t[84]=n("，会存在数据更新问题（数据更新不一致）",-1))]),t[130]||(t[130]=e('<p><strong>分布式缓存</strong>：一种专门做存储的系统（单台服务器或集群）如Redis。只要向其存储一份数据，那么接入该分布式缓存的所有应用服务器可以获取到相同的内容，保证了数据的一致性。举个例子，淘宝商品库存可以放到Redis中，用户在服务器A下了一单库存减少为99，同步更新到Redis，其他用户在服务器B看到的库存也会变成99。</p><ul><li>支持大数据量存储：<strong>分布式缓存是独立部署的进程</strong>，拥有自身独自的内存空间，不需要占用应用程序进程的内存空间，并且还支持横向扩展的集群方式部署，所以可以进行大数据量存储。</li><li>数据不会随着应用程序重启而丢失</li><li>数据集中存储，保证数据的一致性</li><li>数据读写分离，高性能，高可用</li></ul><h4 id="_3-caffeine的实现原理" tabindex="-1"><a class="header-anchor" href="#_3-caffeine的实现原理"><span>（3）Caffeine的实现原理</span></a></h4>',3)),l("p",null,[t[90]||(t[90]=n("Caffeine在设计上注重提高数据访问速度和并发性能。它",-1)),s(o,{style:{"background-color":"#CEF5F7"}},{default:r(()=>[...t[85]||(t[85]=[n("使用",-1)])]),_:1}),t[91]||(t[91]=l("code",null,'<font style="background-color:#CEF5F7;">ConcurrentHashMap</font>',-1)),l("strong",null,[s(o,{style:{"background-color":"#CEF5F7"}},{default:r(()=>[...t[86]||(t[86]=[n("作为底层存储，并结合",-1)])]),_:1})]),s(o,{style:{"background-color":"#CEF5F7"}},{default:r(()=>[...t[87]||(t[87]=[n("LRU（最近最少使用）",-1)])]),_:1}),l("strong",null,[s(o,{style:{"background-color":"#CEF5F7"}},{default:r(()=>[...t[88]||(t[88]=[n("策略来淘汰过期的缓存数据。",-1)])]),_:1}),t[89]||(t[89]=n("****为了优化并发性能，Caffeine采用了",-1))]),t[92]||(t[92]=n("分段锁（Segment）",-1)),t[93]||(t[93]=l("strong",null,"和",-1)),t[94]||(t[94]=n("桶（Bucket）结构，减少线程竞争。",-1))]),s(o,{style:{"background-color":"#CEF5F7"}},{default:r(()=>[...t[95]||(t[95]=[n("Count-Min Sketch 与tiny LRU结合使用，优化缓存项的选择和淘汰。",-1)])]),_:1}),t[131]||(t[131]=n("传统的 LRU 算法通常基于最近的访问时间进行缓存淘汰，但 **Count-Min Sketch** 使得算法可以根据 **访问频率** 做出更智能的决策，从而优化缓存的有效性。，从而有效地管理缓存条目，并确保热点数据得到优先保留。在写操作上，它采用类似**WAL**（Write-Ahead Logging）的机制，通过",-1)),s(o,{style:{color:"rgb(222,120,2)"}},{default:r(()=>[...t[96]||(t[96]=[n("多生产者单消费者模式",-1)])]),_:1}),t[132]||(t[132]=n("来缓存写入任务，从而提高并发写入的效率。",-1)),t[133]||(t[133]=l("blockquote",null,[l("p",null,[l("strong",null,"WAL"),n(" 是一种日志机制，确保数据的变更首先记录到日志文件中，然后才被应用到实际的数据存储中，这样可以保证数据的一致性和恢复。在 Caffeine 中，"),l("code",null,"writeBuffer"),n(" 作为缓存写入的缓冲区，数据先进入这个缓冲区，然后在合适的时机批量刷新到内存缓存中，缓冲区类似于 WAL 的日志记录，确保缓存写入操作的高效性和一致性。")])],-1)),l("table",null,[l("thead",null,[l("tr",null,[l("th",T,[l("strong",null,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[97]||(t[97]=[n("特性",-1)])]),_:1})])]),l("th",L,[l("strong",null,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[98]||(t[98]=[n("普通LRU",-1)])]),_:1})])]),l("th",B,[l("strong",null,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[99]||(t[99]=[n("TinyLRU",-1)])]),_:1})])])])]),l("tbody",null,[l("tr",null,[l("td",E,[l("strong",null,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[100]||(t[100]=[n("内存消耗",-1)])]),_:1})])]),l("td",K,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[101]||(t[101]=[n("较高（使用双向链表 + HashMap）",-1)])]),_:1})]),l("td",D,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[102]||(t[102]=[n("较低（优化的内部结构，减少内存开销）",-1)])]),_:1})])]),l("tr",null,[l("td",S,[l("strong",null,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[103]||(t[103]=[n("数据结构",-1)])]),_:1})])]),l("td",M,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[104]||(t[104]=[n("双向链表 + HashMap",-1)])]),_:1})]),l("td",q,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[105]||(t[105]=[n("单向链表+HashMap",-1)])]),_:1})])]),l("tr",null,[l("td",v,[l("strong",null,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[106]||(t[106]=[n("性能",-1)])]),_:1})])]),l("td",w,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[107]||(t[107]=[n("稍低（由于双向链表维护前后指针）",-1)])]),_:1})]),l("td",A,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[108]||(t[108]=[n("较高（简化的数据结构，减少内存管理复杂性）",-1)])]),_:1})])]),l("tr",null,[l("td",X,[l("strong",null,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[109]||(t[109]=[n("适用场景",-1)])]),_:1})])]),l("td",j,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[110]||(t[110]=[n("内存较充足的环境，功能完整的缓存系统",-1)])]),_:1})]),l("td",U,[s(o,{style:{color:"rgb(0, 0, 0)"}},{default:r(()=>[...t[111]||(t[111]=[n("内存敏感的高并发场景，资源有限时",-1)])]),_:1})])])])]),t[134]||(t[134]=e("<p>Caffeine 选择使用 <strong>单向链表 + HashMap</strong> 作为 <code>TinyLRU</code> 的实现结构，主要是因为它在 <strong>高并发环境下</strong> 提供了 <strong>内存高效</strong> 和 <strong>操作高效</strong> 的优势。相较于 <strong>传统的双向链表</strong>，这种设计的 <strong>内存占用更少</strong>，且对 <strong>LRU 缓存的管理</strong>足够高效，能够在内存和性能之间做出 <strong>更好的平衡</strong>。对于 Caffeine 这样的高性能缓存库来说，减少内存开销并且保证性能是最重要的目标，因此它将 <strong>单向链表</strong> 作为优化方案。</p>",1))])}const W=i(p,[["render",Q]]),P=JSON.parse(`{"path":"/projects/dianping/03.%20%E7%BC%93%E5%AD%98.html","title":"03. 缓存","lang":"en-US","frontmatter":{"title":"03. 缓存","article":false,"category":["项目","《优享生活圈》"],"tag":["redis","缓存优化","本地缓存","多级缓存"],"date":"2026-02-15T00:00:00.000Z","description":"缓存优化：使用防止 Redis 热点 Key 的缓存击穿问题；使用缓存空值方案解决 Redis Key 的缓存穿透问题； 数据一致性：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性； 多级缓存：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redis 压力； 一、缓...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"03. 缓存\\",\\"description\\":\\"缓存优化：使用防止 Redis 热点 Key 的缓存击穿问题；使用缓存空值方案解决 Redis Key 的缓存穿透问题； 数据一致性：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性； 多级缓存：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redis 压力； 一、缓...\\"}"],["meta",{"property":"og:url","content":"https://jiwang.online/projects/dianping/03.%20%E7%BC%93%E5%AD%98.html"}],["meta",{"property":"og:site_name","content":"jiwang's blog"}],["meta",{"property":"og:title","content":"03. 缓存"}],["meta",{"property":"og:description","content":"缓存优化：使用防止 Redis 热点 Key 的缓存击穿问题；使用缓存空值方案解决 Redis Key 的缓存穿透问题； 数据一致性：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性； 多级缓存：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redis 压力； 一、缓..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2026-02-18T14:36:35.000Z"}],["meta",{"property":"article:tag","content":"多级缓存"}],["meta",{"property":"article:tag","content":"本地缓存"}],["meta",{"property":"article:tag","content":"缓存优化"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:published_time","content":"2026-02-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-18T14:36:35.000Z"}]]},"git":{"createdTime":1771425395000,"updatedTime":1771425395000,"contributors":[{"name":"dongjiwang","username":"dongjiwang","email":"1790921341@qq.com","commits":1,"url":"https://github.com/dongjiwang"}]},"readingTime":{"minutes":14.71,"words":4413},"filePathRelative":"projects/dianping/03. 缓存.md","excerpt":"<ol>\\n<li><strong>缓存优化</strong>：使用防止 Redis 热点 Key 的缓存击穿问题；使用缓存空值方案解决 Redis Key 的缓存穿透问题；</li>\\n<li><strong>数据一致性</strong>：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性；</li>\\n<li><strong>多级缓存</strong>：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redis 压力；</li>\\n</ol>\\n<h2>一、缓存击穿</h2>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">背景</p>\\n<p>对于平台的准点开放、限时的一些活动信息 或者 热搜榜单，它们是一个热点数据，在活动上线之前，我们需要提前预热：将其存入 Redis 中进行缓存，目的是提高系统的响应速度，降低数据库的访问压力。</p>\\n<p>当把高并发场景的热点数据存入 Redis 缓存，那么我们需要考虑的问题是：缓存击穿的问题。如果缓存的热点数据失效过期的瞬间，有大量的请求访问，那么大量请求将到达数据库，导致数据库瞬时压力过大甚至可能崩溃。</p>\\n</div>","autoDesc":true}`);export{W as comp,P as data};
