import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as o,d as t,e as i,o as r}from"./app-9neoG83U.js";const a={};function l(c,e){return r(),s("div",null,[e[0]||(e[0]=o("h1",{id:"一、身份认证与保持登录的三种模式",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#一、身份认证与保持登录的三种模式"},[o("span",null,"一、身份认证与保持登录的三种模式")])],-1)),t(' <span style="color: #800000ff;"></span> '),e[1]||(e[1]=i('<h2 id="模式1-cookie-session-传统模式" tabindex="-1"><a class="header-anchor" href="#模式1-cookie-session-传统模式"><span>模式1：Cookie + Session（传统模式）</span></a></h2><img src="https://i.postimg.cc/RZZBhtPb/whiteboard_exported_image_(2).png" alt="session" style="zoom:67%;"><p>具体流程：</p><ol><li>用户输入用户名密码提交登录</li><li>服务器验证通过，创建Session并存储用户信息</li><li>服务器响应：<code>Set-Cookie: JSESSIONID=abc123; HttpOnly</code></li><li>浏览器存储Cookie</li><li>后续请求自动携带：<code>Cookie: JSESSIONID=abc123</code></li><li>服务器通过SessionID查找Session，验证用户身份</li></ol><blockquote><p>其中 <mark>JSESSIONID</mark> 是 Java Web 容器默认用于保存 SessionID 的 Cookie 名称，服务器通过它找到对应的 Session 对象，从而识别用户身份。</p></blockquote><h2 id="模式2-token方案" tabindex="-1"><a class="header-anchor" href="#模式2-token方案"><span>模式2：Token方案</span></a></h2><img src="https://i.postimg.cc/Bnn0bFhV/whiteboard_exported_image_(3).png" alt="单token" style="zoom:67%;"><p>Token流程细节（以JWT为例）：</p><ol><li>客户端提交认证信息</li><li>服务器验证成功后生成JWT：<br> Header.Payload.Signature<br><code>{&quot;userId&quot;: &quot;123&quot;,&quot;username&quot;: &quot;john&quot;,&quot;exp&quot;: 1672531200, &quot;iat&quot;: 1672527600// 签发时间}</code><br> 返回JWT给客户端</li><li>客户端存储JWT</li><li>客户端在后续请求中通过 HTTP Header 自动携带 JWT。注意：这是HTTP Header，不是 JWT Header,别给自己绕晕了。</li><li>服务器验证 JWT 签名，若通过，则解析 Payload 获取用户身份信息，并进行具体的 HTTP 请求处理。</li></ol><h2 id="模式3-session-token混合" tabindex="-1"><a class="header-anchor" href="#模式3-session-token混合"><span>模式3：Session + Token混合</span></a></h2><img src="https://i.postimg.cc/HkkgnMSN/whiteboard_exported_image_(4).png" alt="双token" style="zoom:67%;"><p>在使用 <strong>JWT + Refresh Token</strong> 的登录体系中，Refresh Token 的 <mark>可选刷新机制</mark> 有两个核心作用。</p><p>首先，它可以保证用户长期无缝登录。Access Token 的有效期通常比较短，用于接口访问。当 Access Token 过期时，客户端可以使用 Refresh Token 获取新的 Access Token，从而无需用户重新登录。通过可选刷新机制，服务器可以延长 Refresh Token 的有效期，让用户在不频繁输入密码的情况下持续使用系统。</p><p>其次，可选刷新机制可以提升安全性，防止 Token 被滥用。Refresh Token 如果一直不变，一旦被盗用，攻击者就可能不断刷新 Access Token，长期访问系统。为了降低这种风险，当 Refresh Token 快过期时（比如剩余有效期不到三天），服务器会生成一个新的 Refresh Token，并让旧的失效。这样既保证了长期登录体验，又避免了长时间有效的 Token 被滥用。</p><p>总的来说，可选刷新 Refresh Token 是在 <mark>用户体验与安全性之间的一种平衡</mark>。它只在必要时触发刷新，让用户无需频繁登录，同时保护系统安全。</p><p>值得注意的是，刷新操作 <span style="color:#800000ff;">必须依赖用户的实际请求</span>，否则任何 Token 都会自然过期。比如如果我登陆了一个网站在refresh token的有效期内都没有进行任何操作，那就得重新登录了。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p><strong>传统 Session vs Token-Session (现代无状态 Session)：</strong></p><ul><li><strong>传统 Session</strong>：客户端只持有一个 SessionID，服务器存储所有用户数据（如 <code>userId</code>、<code>name</code>、<code>permissions</code> 等）。</li><li><strong>Token-Session</strong>：客户端持有完整的 Token（包含用户身份信息），服务器不存储用户身份信息，只验证 Token 的签名。</li></ul><h4 id="_1-token-验证流程" tabindex="-1"><a class="header-anchor" href="#_1-token-验证流程"><span>1. <strong>Token 验证流程</strong></span></a></h4><ul><li><strong>Access Token 验证</strong>：服务器只验证 Token 的签名和过期时间，不查询数据库，除非使用了黑名单机制。</li><li><strong>Refresh Token 刷新</strong>：只有在 Access Token 过期或验证失败时，客户端才使用 Refresh Token 进行数据库查询以获取新的 Access Token。</li></ul><h4 id="_2-刷新逻辑" tabindex="-1"><a class="header-anchor" href="#_2-刷新逻辑"><span>2. <strong>刷新逻辑</strong></span></a></h4><ul><li><strong>返回错误而非延长 Token</strong>：服务器不会主动延长 Access Token 的有效期。若 Token 过期，服务器返回 <code>401</code> 错误，提示客户端使用 Refresh Token 刷新 Access Token（两次请求互相独立）。</li><li><strong>控制 Refresh Token 使用频率和撤销</strong>：从无状态的脱缰野马 到 有状态的安全可控。</li></ul><h4 id="_3-refresh-token-刷新流程" tabindex="-1"><a class="header-anchor" href="#_3-refresh-token-刷新流程"><span>3. <strong>Refresh Token 刷新流程</strong></span></a></h4><ul><li><strong>客户端带 Refresh Token 请求刷新</strong>：通过 HttpOnly Cookie 自动携带 Refresh Token。</li><li><strong>服务器验证流程</strong>： <ul><li>计算 <span style="color:#800000ff;">Token 哈希值</span>，查数据库或 Redis 对比存储记录。</li><li>检查 Token 是否被撤销（<code>revoked: true</code>）。</li><li>对比 Token 的过期时间（<code>expiresAt</code>）。</li><li>可选：检查刷新频率等。</li></ul></li><li><strong>验证通过后</strong>：服务器生成新的 Access Token 并可选择更新 Refresh Token（Token 轮换），同时更新最后使用时间。</li><li><strong>返回结果</strong>：返回新的 Access Token 或错误信息。</li></ul><h4 id="_4-安全设计原则" tabindex="-1"><a class="header-anchor" href="#_4-安全设计原则"><span>4. <strong>安全设计原则</strong></span></a></h4><ul><li><strong>Refresh Token 的严格验证</strong>：由于 Refresh Token 是长期凭证，必须对其进行严格管理和撤销控制。服务器存储的过期时间（<code>expiresAt</code>）是权威的，客户端 Cookie 的过期时间仅供参考。即便客户端 Cookie 仍有效，如果服务器端记录已过期或撤销，刷新请求将被拒绝。</li></ul>',27))])}const k=n(a,[["render",l]]),h=JSON.parse(`{"path":"/projects/dianping/01.%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81.html","title":"01. 身份验证","lang":"en-US","frontmatter":{"title":"01. 身份验证","icon":"lock","article":false,"category":["项目","黑马点评"],"tag":["身份验证"],"date":"2026-02-15T00:00:00.000Z","description":"一、身份认证与保持登录的三种模式 模式1：Cookie + Session（传统模式） session 具体流程： 用户输入用户名密码提交登录 服务器验证通过，创建Session并存储用户信息 服务器响应：Set-Cookie: JSESSIONID=abc123; HttpOnly 浏览器存储Cookie 后续请求自动携带：Cookie: JSESS...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"01. 身份验证\\",\\"description\\":\\"一、身份认证与保持登录的三种模式 模式1：Cookie + Session（传统模式） session 具体流程： 用户输入用户名密码提交登录 服务器验证通过，创建Session并存储用户信息 服务器响应：Set-Cookie: JSESSIONID=abc123; HttpOnly 浏览器存储Cookie 后续请求自动携带：Cookie: JSESS...\\"}"],["meta",{"property":"og:url","content":"https://jiwang.online/projects/dianping/01.%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81.html"}],["meta",{"property":"og:site_name","content":"jiwang's blog"}],["meta",{"property":"og:title","content":"01. 身份验证"}],["meta",{"property":"og:description","content":"一、身份认证与保持登录的三种模式 模式1：Cookie + Session（传统模式） session 具体流程： 用户输入用户名密码提交登录 服务器验证通过，创建Session并存储用户信息 服务器响应：Set-Cookie: JSESSIONID=abc123; HttpOnly 浏览器存储Cookie 后续请求自动携带：Cookie: JSESS..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2026-02-15T12:23:26.000Z"}],["meta",{"property":"article:tag","content":"身份验证"}],["meta",{"property":"article:published_time","content":"2026-02-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-15T12:23:26.000Z"}]]},"git":{"createdTime":1771158206000,"updatedTime":1771158206000,"contributors":[{"name":"dongjiwang","username":"dongjiwang","email":"1790921341@qq.com","commits":1,"url":"https://github.com/dongjiwang"}]},"readingTime":{"minutes":4.08,"words":1224},"filePathRelative":"projects/dianping/01.身份验证.md","excerpt":"\\n<!-- <span style=\\"color: #800000ff;\\"></span> -->\\n<h2>模式1：Cookie + Session（传统模式）</h2>\\n<img src=\\"https://i.postimg.cc/RZZBhtPb/whiteboard_exported_image_(2).png\\" alt=\\"session\\" style=\\"zoom:67%;\\">\\n<p>具体流程：</p>\\n<ol>\\n<li>用户输入用户名密码提交登录</li>\\n<li>服务器验证通过，创建Session并存储用户信息</li>\\n<li>服务器响应：<code>Set-Cookie: JSESSIONID=abc123; HttpOnly</code></li>\\n<li>浏览器存储Cookie</li>\\n<li>后续请求自动携带：<code>Cookie: JSESSIONID=abc123</code></li>\\n<li>服务器通过SessionID查找Session，验证用户身份</li>\\n</ol>","autoDesc":true}`);export{k as comp,h as data};
