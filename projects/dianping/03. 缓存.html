<!doctype html>
<html lang="en-US" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.26" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.102" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <script type="application/ld+json">{"@context":"https://schema.org","@type":"WebPage","name":"03. 缓存","description":"缓存优化：使用防止 Redis 热点 Key 的缓存击穿问题；使用缓存空值方案解决 Redis Key 的缓存穿透问题； 数据一致性：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性； 多级缓存：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redis 压力； 一、缓..."}</script><meta property="og:url" content="https://jiwang.online/projects/dianping/03.%20%E7%BC%93%E5%AD%98.html"><meta property="og:site_name" content="jiwang's blog"><meta property="og:title" content="03. 缓存"><meta property="og:description" content="缓存优化：使用防止 Redis 热点 Key 的缓存击穿问题；使用缓存空值方案解决 Redis Key 的缓存穿透问题； 数据一致性：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性； 多级缓存：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redis 压力； 一、缓..."><meta property="og:type" content="website"><meta property="og:locale" content="en-US"><meta property="og:updated_time" content="2026-02-18T14:36:35.000Z"><meta property="article:tag" content="多级缓存"><meta property="article:tag" content="本地缓存"><meta property="article:tag" content="缓存优化"><meta property="article:tag" content="redis"><meta property="article:published_time" content="2026-02-15T00:00:00.000Z"><meta property="article:modified_time" content="2026-02-18T14:36:35.000Z"><link rel="icon" href="/favicon.ico?v=3"><title>03. 缓存 | jiwang's blog</title><meta name="description" content="缓存优化：使用防止 Redis 热点 Key 的缓存击穿问题；使用缓存空值方案解决 Redis Key 的缓存穿透问题； 数据一致性：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性； 多级缓存：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redis 压力； 一、缓...">
    <link rel="preload" href="/assets/style-CBZxUIjk.css" as="style"><link rel="stylesheet" href="/assets/style-CBZxUIjk.css">
    <link rel="modulepreload" href="/assets/app-DJn-akYj.js"><link rel="modulepreload" href="/assets/03. 缓存.html-6ACIxvCX.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/assets/index.html-C6Bg-U_2.js" as="script"><link rel="prefetch" href="/assets/intro.html-BOd9Oc2S.js" as="script"><link rel="prefetch" href="/assets/index.html-C1webI6i.js" as="script"><link rel="prefetch" href="/assets/index.html-CO6Dc6oa.js" as="script"><link rel="prefetch" href="/assets/01. 动态规划.html-1hNQd0Id.js" as="script"><link rel="prefetch" href="/assets/index.html-BtGNMO4J.js" as="script"><link rel="prefetch" href="/assets/index.html-txJ-hbDS.js" as="script"><link rel="prefetch" href="/assets/01. 项目展示.html-YlFAnCcN.js" as="script"><link rel="prefetch" href="/assets/02. 身份认证与保持登录的三种模式.html-B4PBE4b4.js" as="script"><link rel="prefetch" href="/assets/04. 优惠券秒杀.html-Ib8Dxe84.js" as="script"><link rel="prefetch" href="/assets/05. 限流.html-BQurdxxI.js" as="script"><link rel="prefetch" href="/assets/06. LangChain4j AI顾问.html-B13PyeTT.js" as="script"><link rel="prefetch" href="/assets/index.html-DtfeIPba.js" as="script"><link rel="prefetch" href="/assets/404.html-DUNRjLI3.js" as="script"><link rel="prefetch" href="/assets/index.html-Diryz61Q.js" as="script"><link rel="prefetch" href="/assets/index.html-DaiLQFwv.js" as="script"><link rel="prefetch" href="/assets/index.html-Ddmjt5I6.js" as="script"><link rel="prefetch" href="/assets/index.html-BOrqMaip.js" as="script"><link rel="prefetch" href="/assets/index.html-B5vKyQiA.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-CKV1Bsxh.js" as="script"><link rel="prefetch" href="/assets/SearchResult-DTOqhx9M.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">Skip to main content</a><!--]--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/" aria-label="Take me home"><img class="vp-nav-logo" src="https://i.postimg.cc/g2c1xx8J/小太阳头像.png" alt><!----><span class="vp-site-name hide-in-pad">jiwang&#39;s blog</span></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="Home"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:house" sizing="height" height="1em"></iconify-icon><!--]-->Home<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/codenotes/" aria-label="coding"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:code" sizing="height" height="1em"></iconify-icon><!--]-->coding<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link route-link-active auto-link" href="/projects/" aria-label="project"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:free" sizing="height" height="1em"></iconify-icon><!--]-->project<!----></a></div></nav><!--]--></div><div class="vp-navbar-end"><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/jiwangdx/" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><!----><!--[--><button type="button" class="slimsearch-button" aria-label="Search"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="slimsearch-placeholder">Search</div><div class="slimsearch-key-hints"><kbd class="slimsearch-key">Ctrl</kbd><kbd class="slimsearch-key">K</kbd></div></button><!--]--><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/projects/dianping/" aria-label="《优享生活圈》"><!---->《优享生活圈》<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/projects/dianping/01.%20%E9%A1%B9%E7%9B%AE%E5%B1%95%E7%A4%BA.html" aria-label="01. 项目展示"><!---->01. 项目展示<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/projects/dianping/02.%20%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E4%BF%9D%E6%8C%81%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.html" aria-label="02. 身份认证与保持登录的三种模式"><!---->02. 身份认证与保持登录的三种模式<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/projects/dianping/03.%20%E7%BC%93%E5%AD%98.html" aria-label="03. 缓存"><!---->03. 缓存<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/projects/dianping/04.%20%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80.html" aria-label="04. 优惠券秒杀"><!---->04. 优惠券秒杀<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/projects/dianping/05.%20%E9%99%90%E6%B5%81.html" aria-label="05. 限流"><!---->05. 限流<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/projects/dianping/06.%20LangChain4j%20AI%E9%A1%BE%E9%97%AE.html" aria-label="06. LangChain4j AI顾问"><!---->06. LangChain4j AI顾问<!----></a></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->03. 缓存</h1><div class="page-info"><span class="page-author-info" aria-label="Author🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://jiwang.online/" target="_blank" rel="noopener noreferrer">jiwang</a></span><span property="author" content="jiwang"></span></span><!----><span class="page-date-info" aria-label="Writing Date📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">2/15/26</span><meta property="datePublished" content="2026-02-15T00:00:00.000Z"></span><!----><span class="page-reading-time-info" aria-label="Reading Time⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>About 15 min</span><meta property="timeRequired" content="PT15M"></span><span class="page-category-info" aria-label="Category🌈" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon" name="category"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item color4" role>项目</span><span class="page-category-item color0" role>《优享生活圈》</span><!--]--><meta property="articleSection" content="项目,《优享生活圈》"></span><span class="page-tag-info" aria-label="Tag🏷" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon" name="tag"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item color8" role>redis</span><span class="page-tag-item color7" role>缓存优化</span><span class="page-tag-item color0" role>本地缓存</span><span class="page-tag-item color4" role>多级缓存</span><!--]--><meta property="keywords" content="redis,缓存优化,本地缓存,多级缓存"></span></div><hr></div><!----><div class="" vp-content><!----><div id="markdown-content"><ol><li><strong>缓存优化</strong>：使用<!---->防止 Redis 热点 Key 的缓存击穿问题；使用缓存空值方案解决 Redis Key 的缓存穿透问题；</li><li><strong>数据一致性</strong>：更新数据库后删除缓存，若删除失败消息队列补偿重试，TTL 兜底共同保证数据一致性；</li><li><strong>多级缓存</strong>：使用 Caffeine 本地缓存 和 Redis 缓存搭建二级缓存架构，提高热点数据访问速度，降低 Redis 压力；</li></ol><h2 id="一、缓存击穿" tabindex="-1"><a class="header-anchor" href="#一、缓存击穿"><span>一、缓存击穿</span></a></h2><div class="hint-container info"><p class="hint-container-title">背景</p><p>对于平台的准点开放、限时的一些活动信息 或者 热搜榜单，它们是一个热点数据，在活动上线之前，我们需要提前预热：将其存入 Redis 中进行缓存，目的是提高系统的响应速度，降低数据库的访问压力。</p><p>当把高并发场景的热点数据存入 Redis 缓存，那么我们需要考虑的问题是：缓存击穿的问题。如果缓存的热点数据失效过期的瞬间，有大量的请求访问，那么大量请求将到达数据库，导致数据库瞬时压力过大甚至可能崩溃。</p></div><p>解决缓存击穿的问题，有两种解决方案：一是使用互斥锁。二是使用逻辑过期。</p><p><strong><!----></strong><!----></p><p>当缓存失效时，有大量请求都会去访问数据库，希望获取数据且重新建立缓存再返回给用户数据。<strong>但其实只需要一个请求对应的线程去访问数据库，重新建立起缓存即可</strong>。</p><p>在请求到达缓存后，若缓存不存在，尝试获取互斥锁，大量的请求中，只有一个线程获取锁成功，由这个线程去查询数据库，重新建立缓存，而其他的请求线程获取锁失败，都休眠一小段时间后，不断重试获取缓存数据。</p><blockquote><p><strong>互斥锁的方案，最终只有一个线程去访问数据库，降低了数据库的访问压力，解决了缓存击穿的问题，但是其他的线程需要等待，性能受到影响，对于外界可能表现出一些不可用或者延迟的现象，但是保证了强一致性。</strong></p></blockquote><p><strong><!----></strong></p><p>针对热点数据我们<strong>不设置TTL</strong>，也就是说Redis Key永不失效，而是在Redis的Value数据中新增一个属性存储过期时间字段。</p><p>在获取key时需要检查过期时间字段，判断是否过期，如果发现过期，则尝试获取互斥锁，大量的请求中，只有一个线程获取锁成功，由这个线程去开启一个独立线程去查询数据库重建缓存，而其他线程就直接返回Redis中的旧数据。</p><blockquote><p><strong>这个逻辑过期的方案，最终也是只有一个线程去访问数据库，降低了数据库的访问压力，解决了缓存击穿的问题，并且线程无需等待，性能比较好，保证了服务的可用性，但是部分请求返回了Redis的旧数据，没有保证一致性。</strong></p></blockquote><p>这两个方案的对比，其实就是 **可用性和一致性的抉择 (CAP定理) **：</p><ul><li>互斥锁保证了一致性，牺牲了可用性；</li><li>逻辑过期保证了可用性，而牺牲了一致性</li></ul><p><strong>针对这个热搜榜单，它其实是一种社交媒体类型的数据，对于一致性的要求不是很高，因此最终为了保证服务的可用性，选择使用逻辑过期的方案来解决缓存击穿问题。</strong></p><p>在测试阶段，(手动修改数据库中的数据，使得Redis和MySQL数据不一致)，然后等到Redis中的数据逻辑上过期后，使用 Jmeter 进行压力测试，在5s内5000个线程并发请求，QPS是1000，<!---->，<strong>证明在高并发的场景下，没有让所有的请求打到数据库，成功使用逻辑过期方案解决缓存击穿问题</strong>。缺点就是在缓存尚未重建完毕时，前面一小部分的请求(大概200ms是缓存重建的耗时)获取到的是旧的Redis数据，后面所有的请求获取到的是正确的数据。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>金融类的业务场景，是要求强一致性的，会使用互斥锁方案。</p></div><h2 id="二、数据一致性" tabindex="-1"><a class="header-anchor" href="#二、数据一致性"><span>二、数据一致性</span></a></h2><h3 id="_2-1-问题解决" tabindex="-1"><a class="header-anchor" href="#_2-1-问题解决"><span>2.1. 问题解决</span></a></h3><div class="hint-container info"><p class="hint-container-title">背景</p><p>把数据存入Redis缓存，MySQL中的数据是会更新的，需要设法保证Redis和MySQL的数据一致性。</p></div><p>在<!---->，若删除缓存失败，则发送一个消息到Kafka中，消息中携带上要删除的key的信息，同时需要启动Kafka消费者，消费者接收到消息后执行缓存删除逻辑。如果删除缓存失败，消息队列的重试机制就可以发挥作用，<strong>梯度重试</strong>的去删除缓存，<strong>尽量保证</strong>数据的<strong>最终一致性</strong>。</p><blockquote><p>梯度重试（Exponential Backoff）是一种用于处理失败的重试机制，它会根据重试的次数逐渐增加重试的间隔时间，避免在短时间内频繁地重复操作，从而减少系统的负载和资源消耗。</p><ul><li>删除缓存还是更新缓存？ <ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：<!---->，查询时再更新缓存</li></ul></li></ul></blockquote><div class="hint-container warning"><p class="hint-container-title">注意</p><p>当然保证数据一致性还有很多方案，例如binlog 监听同步，<!---->。当然上述方法都不能保证MySQL数据和Redis缓存的数据强一致性，只是保证最终一致性。</p><p><strong>无论选择哪种方案都需要为缓存设置TTL，作为兜底策略。&quot;设置过期时间&quot;就像是给缓存加了&quot;自动清理保险&quot;，即使我们主动删除失败，系统也能在一定时间后自我修复，避免永久性的数据不一致。</strong></p></div><h3 id="_2-2-衍生思考" tabindex="-1"><a class="header-anchor" href="#_2-2-衍生思考"><span>2.2 衍生思考</span></a></h3><h4 id="_1-使用消息队列重试-如果一直失败怎么办" tabindex="-1"><a class="header-anchor" href="#_1-使用消息队列重试-如果一直失败怎么办"><span>（1）使用消息队列重试，如果一直失败怎么办？</span></a></h4><p><strong>记录失败次数</strong>，程序里检测达到最大重试次数后，<strong>触发告警，人工介入排查原因</strong></p><h4 id="_2-为什么是先更新mysql-后删除redis缓存" tabindex="-1"><a class="header-anchor" href="#_2-为什么是先更新mysql-后删除redis缓存"><span>（2）为什么是先更新MySQL，后删除Redis缓存？</span></a></h4><p>选择“先更新数据库，再删除缓存”，核心考虑是<!---->。</p><!----><p><code>从不一致窗口的角度来看</code>，这里数据不一致的时间，就是缓存删除的时间。</p><p><code>从数据不一致的原因来看</code>，分析如下，初始状态为<code>缓存：null，DB：X1</code></p><pre><code>1. 读请求：缓存未命中，读取数据库的值为`X1`
2. 写请求：请求更新数据库的值为`X2`，并且执行删除缓存的操作
3. 读请求：将`X1`写回缓存
</code></pre><p>这样最终状态是<code>DB：X2``缓存：X1</code> 不一致</p><blockquote><p><strong>但上述情况出现的概率很小</strong>：因为 <code>更新MySQL的耗时 &gt;&gt; 读请求写入Redis缓存的耗时</code>，正常流程下就是读缓存未命中--&gt;读数据库拿到值写入redis--&gt;写请求完成mysql更新并且删除缓存，即最终状态为<code>DB：X2``缓存：null</code> 。</p></blockquote><p><code>考虑更新失败的情况：万一数据库出了啥问题更新失败</code>，Redis没删除，数据库和缓存还是一致的，<code>万一缓存删除失败</code>，可以消息队列重试或者设置过期时间兜底，这就是可修复的不一致。</p><!----><p><code>从不一致窗口的角度来看</code>，这里数据不一致的时间，看起来是缩短了。确实，如果没有高并发，看起来可以忽略不计，但高并发会让<!---->变得很大。</p><p><code>**从数据不一致的原因来看**</code><strong>，分析如下，初始状态为</strong><code>**缓存：null，DB：X1**</code></p><pre><code>1. 写请求：删除缓存
2. 读请求：缓存未命中、读取数据库的值，更新缓存值为`X1`
3. 写请求：更新数据库的值为`X2`
</code></pre><p>这时不一致窗口就<!---->为 <code>本次DB更新的时间+下次更新操作来临时删除缓存的时间</code>。</p><blockquote><p>最致命的是上述情况发生概率很大，因为<code>更新MySQL的耗时 &gt;&gt; 删除Redis缓存的耗时</code>，所以很有可能会有并发读请求在&quot;删除缓存&quot;和&quot;更新数据库&quot; 之间执行，导致数据不一致。</p></blockquote><p><code>考虑DB更新失败的情况：</code>缓存已经不在了，但是数据库没更新，就会导致超卖。</p><table><thead><tr><th style="text-align:center;"><strong><!----></strong></th><th style="text-align:center;"><strong><!----></strong></th><th style="text-align:center;"><strong><!----></strong></th></tr></thead><tbody><tr><td style="text-align:center;"><!----></td><td style="text-align:center;"><!----></td><td style="text-align:center;"><!----></td></tr><tr><td style="text-align:center;"><!----></td><td style="text-align:center;"><!----></td><td style="text-align:center;"><!----></td></tr></tbody></table><h4 id="_3-什么是延迟双删" tabindex="-1"><a class="header-anchor" href="#_3-什么是延迟双删"><span>（3）什么是延迟双删</span></a></h4><pre><code>1. 先删除缓存
2. 更新数据库
3. 延迟一定时间后，删除缓存
</code></pre><h2 id="三、多级缓存" tabindex="-1"><a class="header-anchor" href="#三、多级缓存"><span>三、多级缓存</span></a></h2><h3 id="_3-1-问题解决" tabindex="-1"><a class="header-anchor" href="#_3-1-问题解决"><span>3.1 问题解决</span></a></h3><div class="hint-container info"><p class="hint-container-title">背景</p><p>对于一些存储在Redis中的过热的key，例如秒杀优惠券的详情页，它本身是<strong>更新频率极低的，访问频率很高</strong>的数据。而Redis单实例性能有上限，单个Redis的压力过大，Redis可能成为系统瓶颈。</p></div><p>考虑使用**<!----><strong>，搭建二级缓存，本地缓存将</strong>热 Key 的访问压力分散到各个应用实例的内存中，显著降低Redis的访问压力。**</p><p>搭建二级缓存架构后，用户的请求流程将会是</p><ul><li>先从本地缓存中获取数据，如果本地缓存有数据则返回数据</li><li>否则从Redis缓存中获取数据。<!---->，然后将数据返回客户端</li><li>如果Redis缓存没有数据则去数据库查询数据，然后更新Redis缓存，接着再更新本地缓存，最后将数据返回给客户端</li></ul><p>当然使用本地缓存，有一个<!---->是，<!----><strong><!----></strong><!---->，如果数据库的数据有更新的情况，本地缓存的数据和数据库的数据会出现<strong>数据不一致窗口</strong>，如果要更新/删除本地缓存的数据，因为是集群部署，就要把所有节点的本地缓存的数据都进行更新/删除，此时这个实现稍微有些复杂，例如发送广播消息，所有实例节点监听广播消息，然后在本地缓存更新/删除。</p><p>可以使用一种更简单的方法，就是我们可以**<!---->**，这样我们可以不用去管本地缓存的数据更新，而是仅依靠TTL，去不断刷新本地缓存的数据。</p><h3 id="_3-2-衍生思考" tabindex="-1"><a class="header-anchor" href="#_3-2-衍生思考"><span>3.2 衍生思考</span></a></h3><h4 id="_1-redis单实例压力过大-为什么不搭建redis集群" tabindex="-1"><a class="header-anchor" href="#_1-redis单实例压力过大-为什么不搭建redis集群"><span>（1）Redis单实例压力过大，为什么不搭建Redis集群</span></a></h4><p>第一考虑成本问题，第二<code>即使搭建了Redis集群，热Key存在于某个Redis实例上</code>，依然会使得单台Redis实例压力过大，除非对该热Key进行分片，分散到不同的Redis实例上，这样实现复杂度又增加了。所以可以选择本地缓存方案，简单。</p><h4 id="_2-分布式缓存" tabindex="-1"><a class="header-anchor" href="#_2-分布式缓存"><span>（2）分布式缓存</span></a></h4><p><strong>本地缓存</strong>：是单台应用服务器维度的缓存，会占用服务器本身存储空间。假设一个分布式系统有5台应用服务器，那么这5台服务器中的缓存内容是**<!---->**的，彼此不相互影响。<!----></p><p>优点：本地缓存不需要远程网络请求去操作内存空间，没有额外的性能消耗，所以读取速度快。</p><p>缺点：不能进行大数据量存储；<!---->，会存在数据更新问题（数据更新不一致）</p><p><strong>分布式缓存</strong>：一种专门做存储的系统（单台服务器或集群）如Redis。只要向其存储一份数据，那么接入该分布式缓存的所有应用服务器可以获取到相同的内容，保证了数据的一致性。举个例子，淘宝商品库存可以放到Redis中，用户在服务器A下了一单库存减少为99，同步更新到Redis，其他用户在服务器B看到的库存也会变成99。</p><ul><li>支持大数据量存储：<strong>分布式缓存是独立部署的进程</strong>，拥有自身独自的内存空间，不需要占用应用程序进程的内存空间，并且还支持横向扩展的集群方式部署，所以可以进行大数据量存储。</li><li>数据不会随着应用程序重启而丢失</li><li>数据集中存储，保证数据的一致性</li><li>数据读写分离，高性能，高可用</li></ul><h4 id="_3-caffeine的实现原理" tabindex="-1"><a class="header-anchor" href="#_3-caffeine的实现原理"><span>（3）Caffeine的实现原理</span></a></h4><p>Caffeine在设计上注重提高数据访问速度和并发性能。它<!----><code>&lt;font style=&quot;background-color:#CEF5F7;&quot;&gt;ConcurrentHashMap&lt;/font&gt;</code><strong><!----></strong><!----><strong><!---->****为了优化并发性能，Caffeine采用了</strong>分段锁（Segment）<strong>和</strong>桶（Bucket）结构，减少线程竞争。</p><!---->传统的 LRU 算法通常基于最近的访问时间进行缓存淘汰，但 **Count-Min Sketch** 使得算法可以根据 **访问频率** 做出更智能的决策，从而优化缓存的有效性。，从而有效地管理缓存条目，并确保热点数据得到优先保留。在写操作上，它采用类似**WAL**（Write-Ahead Logging）的机制，通过<!---->来缓存写入任务，从而提高并发写入的效率。<blockquote><p><strong>WAL</strong> 是一种日志机制，确保数据的变更首先记录到日志文件中，然后才被应用到实际的数据存储中，这样可以保证数据的一致性和恢复。在 Caffeine 中，<code>writeBuffer</code> 作为缓存写入的缓冲区，数据先进入这个缓冲区，然后在合适的时机批量刷新到内存缓存中，缓冲区类似于 WAL 的日志记录，确保缓存写入操作的高效性和一致性。</p></blockquote><table><thead><tr><th style="text-align:center;"><strong><!----></strong></th><th style="text-align:center;"><strong><!----></strong></th><th style="text-align:center;"><strong><!----></strong></th></tr></thead><tbody><tr><td style="text-align:center;"><strong><!----></strong></td><td style="text-align:center;"><!----></td><td style="text-align:center;"><!----></td></tr><tr><td style="text-align:center;"><strong><!----></strong></td><td style="text-align:center;"><!----></td><td style="text-align:center;"><!----></td></tr><tr><td style="text-align:center;"><strong><!----></strong></td><td style="text-align:center;"><!----></td><td style="text-align:center;"><!----></td></tr><tr><td style="text-align:center;"><strong><!----></strong></td><td style="text-align:center;"><!----></td><td style="text-align:center;"><!----></td></tr></tbody></table><p>Caffeine 选择使用 <strong>单向链表 + HashMap</strong> 作为 <code>TinyLRU</code> 的实现结构，主要是因为它在 <strong>高并发环境下</strong> 提供了 <strong>内存高效</strong> 和 <strong>操作高效</strong> 的优势。相较于 <strong>传统的双向链表</strong>，这种设计的 <strong>内存占用更少</strong>，且对 <strong>LRU 缓存的管理</strong>足够高效，能够在内存和性能之间做出 <strong>更好的平衡</strong>。对于 Caffeine 这样的高性能缓存库来说，减少内存开销并且保证性能是最重要的目标，因此它将 <strong>单向链表</strong> 作为优化方案。</p></div><!----><!----><!----></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">Last Updated: </span><time class="vp-meta-info" datetime="2026-02-18T14:36:35.000Z" data-allow-mismatch>2/18/26, 2:36 PM</time></div><div class="contributors"><span class="vp-meta-label">Contributors: </span><!--[--><!--[--><span class="vp-meta-info" title="email: 1790921341@qq.com">dongjiwang</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/projects/dianping/02.%20%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E4%B8%8E%E4%BF%9D%E6%8C%81%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.html" aria-label="02. 身份认证与保持登录的三种模式"><div class="hint"><span class="arrow start"></span>Prev</div><div class="link"><!---->02. 身份认证与保持登录的三种模式</div></a><a class="route-link auto-link next" href="/projects/dianping/04.%20%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80.html" aria-label="04. 优惠券秒杀"><div class="hint">Next<span class="arrow end"></span></div><div class="link">04. 优惠券秒杀<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><div class="vp-footer">光荣在于平淡，艰巨在于漫长</div><div class="vp-copyright">Copyright © 2026 jiwang </div></footer></div><!--]--><!--[--><!----><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/assets/app-DJn-akYj.js" defer></script>
  </body>
</html>
